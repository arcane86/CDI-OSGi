<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 3. How to make OSGi easy peasy</title><link rel="stylesheet" href="css/seamframework.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="CDI OSGi integration"/><link rel="up" href="index.html" title="CDI OSGi integration"/><link rel="prev" href="ch02.html" title="Chapter 2. Organization of CDI-OSGi"/><link rel="next" href="ch04.html" title="Chapter 4. Weld-OSGi implementation"/></head><body><p id="title"><a href="http://www.seamframework.org" class="site_href"><strong>SeamFramework.org</strong></a><a href="http://www.seamframework.org/Documentation" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch02.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch04.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1282"/>Chapter 3. How to make OSGi easy peasy</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch03.html#d0e1285">3.1. CDI usage in bean bundles</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1292">3.2. Injecting easiness in OSGi world</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d0e1305">3.2.1. Service, implementation, instance and registration</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1318">3.2.2. OSGi services injection</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1369">3.2.3. OSGi service automatic publishing with @Publish annotation </a></span></dt><dt><span class="section"><a href="ch03.html#d0e1405">3.2.4. Clearly specify a service implementation</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1563">3.2.5. Contextual services</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1584">3.2.6. The registration</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1636">3.2.7. Service registry</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1676">3.2.8. The OSGiServiceUnavailableException exception</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#d0e1686">3.3. CDI-OSGi events</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d0e1693">3.3.1. CDI container lifecycle events</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1739">3.3.2. Bundle lifecycle events</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1800">3.3.3. Service lifecyle events</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1867">3.3.4. Application dependency validation events</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1899">3.3.5. Intra and inter bundles communication events</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#d0e1954">3.4. OSGi utilities</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d0e1959">3.4.1. From the current bundle</a></span></dt><dt><span class="section"><a href="ch03.html#d0e1981">3.4.2. From external bundle</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#d0e1998">3.5. CDI-OSGi, what else ?</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#d0e2003">3.5.1. Getting service references and instances</a></span></dt><dt><span class="section"><a href="ch03.html#d0e2036">3.5.2. Publishing a service implementation</a></span></dt><dt><span class="section"><a href="ch03.html#d0e2053">3.5.3. Obtaining the Bundles and BundleContexts</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1285"/>3.1. CDI usage in bean bundles</h2></div></div></div><p>Everything possible in CDI applications is possible in bean bundle. They can take
            advantage of injection, producers, interceptors, decorators and alternative. But
            influence boundary of the CDI compliant container stay within the bean bundle for
            classic CDI usages. So external dependencies cannot be injected and interceptor,
            decorator or alternative of another bean bundle cannot be used (yet interceptors,
            decorators and alternatives still need to be declares in the bean bundle bean.xml file). </p><p>That is all we will say about classic CDI usages, please report to CDI documentation
            for more information.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1292"/>3.2. Injecting easiness in OSGi world</h2></div></div></div><p>CDI-OSGi provides more functionality using CDI in a OSGi environment.</p><p>It mainly focuses on the OSGi service layer. It addresses the difficulties in
            publishing and consuming services. CDI-OSGi allows developers to publish and consume
            OSGi services as CDI beans. However, since OSGi services are dynamic there are some
            differences with classic bean injection. This section presents how OSGi services can be
            published and consumed using CDI-OSGi.</p><p>CDI-OSGi also provides utilities for event notification and communication in and
            between bundles as well as some general OSGi utilities.</p><p>Examples use this very sophisticated service interface:
            </p><pre class="programlisting">public interface MyService {
    void doSomething();
}</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1305"/>3.2.1. Service, implementation, instance and registration</h3></div></div></div><p>First it is important to be clear about what are a service, its implementations,
                its instances and its registrations.</p><p>A service is mostly an interface. This interface defines the contract that
                describes what the service may do. It might be several way to actually providing the
                service, thus a service might have multiple implementations.</p><p>A service implementation is a class that implements this service. It is what is
                available to other components that use the service. To use the service the component
                obtain an instance of the implementation.</p><p>A service instance is an instance of one of the service implementations. It is
                what the user manipulates to perform the service.</p><p>A registration is the object that represents a service registered with a
                particular implementation. Then this implementation can be searched and its
                instances can be obtained. Every time a service implementation his register a
                corresponding registration object is created.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1318"/>3.2.2. OSGi services injection</h3></div></div></div><p> There are two ways to obtain a service instances using CDI-OSGi: direct injection
                and programmatic lookup.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1323"/>3.2.2.1. Direct injection using <code class="code">@OSGiService</code> annotation </h4></div></div></div><p>The main way to perform an OSGi injection is to use the <code class="code">@Inject
                        @OSGiService</code> annotation combination. It acts like a common injection
                    except that CDI-OSGi will search for injectable instances in the service
                    registry.</p><p>That is how it looks like:
                    </p><pre class="programlisting">@Inject @OSGiService MyService service;
service.doSomething(); </pre><p>The behavior is similar with classic CDI injection. <code class="code">@OSGiService</code>
                    is just a special qualifier that allows extension bundle to manage the injection
                    instead of CDI implementation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1343"/>3.2.2.2. Injection using programmatic lookup</h4></div></div></div><p>Instead of obtain directly a service instance it is possible to choose between
                    service implementations and instantiate one at runtime. The interface
                        <code class="code">Service&lt;T&gt;</code> works as a service instance producer: it
                    retrieves all the corresponding (to the service parametrized type) service
                    implementations and allows to get an instance for each.</p><p>Service implementations and a corresponding instance can be obtained like
                    that:
                    </p><pre class="programlisting">@Inject Service&lt;MyService&gt; services;
services.get().doSomething();</pre><p>All
                    implementations can also be iterated like that:
                    </p><pre class="programlisting">@Inject Service&lt;MyService&gt; services;
for (MyService service : services) {
    service.get().doSomething();
}</pre><p>The
                        <code class="code">get()</code> method returns an instance of the first available service
                    implementation.</p><p><code class="code">Service&lt;T&gt;</code> acts like CDI <code class="code">Instance&lt;T&gt;</code> except
                    that the injection process is managed by the extension bundle instead of  CDI
                    implementation. So the available implementations are searched dynamically into
                    the service registry.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1369"/>3.2.3. OSGi service automatic publishing with <code class="code">@Publish</code> annotation </h3></div></div></div><p>CDI-OSGi allows developers to automatically publish service implementation. There
                is nothing to do, just put the annotation. OSGi framework is completely hidden. Then
                the service is accessible through CDI-OSGi service injection and OSGi classic
                mechanisms.</p><p>Automatically publish a new service implementation:
                </p><pre class="programlisting">@Publish
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}</pre><p>It
                registers a service <code class="code">MyService</code> with the implementation
                    <code class="code">MyServiceImpl</code>.</p><p>The behavior is similar with classic CDI bean registration, except that services
                are not register into the bean manager but into the service registry.</p><p>It is possible to specify the contracts interface that this specific
                implementation fulfill using the <code class="code">Publish</code> annotation.</p><p>
                </p><pre class="programlisting">@Publish(contracts = {MyService.class, MyOtherService.class})
public class MyServiceImpl {

    public void doSomething() {
    }
}</pre><p>
            </p><p>If no contract list are provided, the implementation will match each of its
                interface types. Every CDI container of a bean bundle might have a blacklist that
                excludes some interface from being register as a service type. See the specific
                integration bundle doccumentation to obtain the used blacklist. This blacklist is
                only used when no interface array is provided within the <code class="code">Publish</code>
                annotation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1405"/>3.2.4. Clearly specify a service implementation</h3></div></div></div><p>There might be multiple implementations of the same service. It is possible to
                provide properties to an implementation in CDI-OSGi. This qualification is available
                both during publishing and consuming.</p><p>There are two ways for qualifying: a CDI like and a OSGi like, both are presented
                below.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1412"/>3.2.4.1. Using <code class="code">@Qualifier</code> annotations</h4></div></div></div><p>Qualifiers are used like in classic CDI applications. An implementation can be
                    qualified by as many qualifiers as needed. An injection point can be also
                    qualified in order to restraint the potential injected implementations. It is
                    finally possible to select the instance produced when using the
                        <code class="code">Service&lt;T&gt;</code> interface.</p><p>Qualified service publishing:
                    </p><pre class="programlisting">
@Publish
@AnyQualifier
public class MyServiceQualifiedImpl implements MyService {

    @Override
    public void doSomething() {
    }
}                </pre><p>Qualified
                    injection point:
                    </p><pre class="programlisting">
@Inject @OSGiService @AnyQualifier MyService qualifiedService; 
qualifiedService.doSomething();</pre><p>or
                    with <code class="code">Service&lt;T&gt;</code>
                    </p><pre class="programlisting">
@Inject @AnyQualifier Service&lt;MyService&gt; service;
service.get().doSomething();</pre><p>The qualifiers should be seen as the service properties. Here another example:
                    </p><pre class="programlisting">@Publish
@Lang(EN)
@Country(US)
@ApplicationScoped
public class MyServiceImpl implements MyService {

    @Override
    public void doSomething() {
    }
}

@Inject @Lang(EN) @Country(US) Service&lt;MyService&gt; service;</pre><p>The behavior is similar with classic CDI qualifiers. But there another
                    possibility in order to qualify a service.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1442"/>3.2.4.2. Filtering services</h4></div></div></div><p>Since CDI-OSGi services stay OSGi services they can be filtered through LDAP
                    filter. Properties might be added at publishing using the <code class="code">Publish</code>
                    annotation values. Then an LDAP filter can be use at injection point using the
                        <code class="code">Filter</code> annotation. </p><p>An example is worth a thousand words:
                    </p><pre class="programlisting">@Publish({
    @Property(name="lang", value="EN"),
    @Property(name="country", value="US")
})
@ApplicationScoped
public class MyServiceImpl implements MyService {

    @Override
    public void doSomething() {
    }
}</pre><p>As
                    many <code class="code">@Property</code> annotation as wanted can be added, they are
                    registered with the service implementation.</p><p>Then it is possible to filter an injection point with the <code class="code">Filter</code>
                    annotation like a regular LDAP filter:
                    </p><pre class="programlisting">@Inject @Filter("(&amp;(lang=*)(country=US))") Service&lt;MyService&gt; service;</pre><p>or</p><pre class="programlisting">@Inject @Filter("(&amp;(lang=*)(country=US))") MyService service;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1471"/>3.2.4.3. Links between qualifier annotations and LDAP filtering</h4></div></div></div><p>A service implementation has properties. These properties can be added by both
                        <code class="code">Qualifier</code> annotations and <code class="code">Property</code> annotations of
                    a <code class="code">Filter</code> annotation. Therefore there is a link between
                        <code class="code">Qualifier</code> and LDAP filter used in <code class="code">Filter</code>
                    annotation as <code class="code">Property</code>.</p><p>A property is a couple of <code class="code">String</code>, the first entry is the name of
                    the property, the second the value. This scheme is clear in the
                        <code class="code">Property</code> annotation. For <code class="code">Qualifier</code> the property
                    name is the decapitalized <code class="code">Qualifier</code> class name and the property
                    value is the <code class="code">value</code> of the <code class="code">Qualifier</code> (empty
                        <code class="code">String</code> is assumed if <code class="code">value</code> does not exist).</p><p>
                    </p><pre class="programlisting">@Publish
@Lang(EN)
@Country(US)
@ApplicationScoped
public class MyServiceImpl implements MyService {
}

@Inject @Filter("(&amp;(lang=EN)(country=US))") Service&lt;MyService&gt; service;</pre><p>
                </p><p>
                    </p><pre class="programlisting">@Publish({
    @Property(name="lang", value="EN"),
    @Property(name="country", value="US")
})
@ApplicationScoped
public class MyServiceImpl implements MyService {
}

@Inject @Lang(EN) @Country(US) Service&lt;MyService&gt; service;</pre><p>
                </p><p>It is even possible to mix up <code class="code">Qualifier</code> and
                    <code class="code">Property</code>:
                    </p><pre class="programlisting">@Publish({
    @Property(name="lang", value="EN"),
})
@Country(US)
@ApplicationScoped
public class MyServiceImpl implements MyService {
}

@Inject @Filter("lang=EN") @Country(US) Service&lt;MyService&gt; service;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1540"/>3.2.4.4. Filtering after injection</h4></div></div></div><p>It is possible to do a programmatic filtering after injection using
                        <code class="code">Service&lt;T&gt;</code> like with
                    <code class="code">Instance&lt;T&gt;</code>:</p><pre class="programlisting">@Inject Service&lt;MyService&gt; services;
services.select(new AnnotationLiteral&lt;AnyQualifier&gt;() {}).get().deSomething();</pre><p>or</p><pre class="programlisting">@Inject Service&lt;MyService&gt; services;
services.select("(&amp;(lang=*)(country=US))").get().deSomething();</pre><p>However OSGi service may not be subtyped, thus it is not possible to use
                        <code class="code">select()</code> methods with a specified subclass like with
                        <code class="code">Instance&lt;T&gt;</code></p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1563"/>3.2.5. Contextual services</h3></div></div></div><p>Like for bean instances, service instances are contextual. Every implementation is
                bounded to a particular scope. Provided that an satisfactory implementation is
                available, a service injection will return a contextual instance of the
                implementation.</p><p>All CDI scopes are available for CDI-OSGi services and their use is the same:
                </p><pre class="programlisting">@Publish
@ApplicationScoped
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}</pre><p>A
                instance will be shared by the entire
                application.</p><pre class="programlisting">@Publish
@RequestScoped
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}                </pre><p>A
                new instance is created for every request.</p><p>If no scope is provided <code class="code">Dependent</code> scope is assumed, a new instance
                will be create for every injection. An instance obtained with regular OSGi
                mechanisms assumes a <code class="code">ApplicationScoped</code> scope in order to maintain
                regular OSGi comportment.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1584"/>3.2.6. The registration</h3></div></div></div><p>A registration object represent all the bindings between a service contract class
                and its OSGi <code class="code">ServiceRegistration</code>s. With this object it is possible to
                navigate through multiple implementations of the same service, obtain the
                corresponding <code class="code">Service&lt;T&gt;</code> or unregister these implementations.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1595"/>3.2.6.1. registration injection</h4></div></div></div><p>A registration is obtained like
                    that:</p><pre class="programlisting">@Inject Registration&lt;MyService&gt; registrations;</pre><p>The
                    injection point can be filtered using
                    qualifiers:</p><pre class="programlisting">@Inject @AnyQualifier Registration&lt;MyService&gt; qualifiedRegistrations;</pre><p>or
                    using LDAP
                    filter:</p><pre class="programlisting">@Inject @Filter("(&amp;(lang=EN)(country=US))") Registration&lt;MyService&gt; qualifiedRegistrations;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1608"/>3.2.6.2. Navigate into registrations and filter them</h4></div></div></div><p>It is possible to iterate through
                    registration:</p><pre class="programlisting">if(registrations.size() &gt; 0) {
    for(Registration&lt;T&gt; registration : registrations) {
    }
}</pre><p>It is also possible to request a subset of the service implementations using
                    qualifiers:</p><pre class="programlisting">Registration&lt;T&gt; filteredRegistrations = registrations.select(new AnnotationLiteral&lt;AnyQualifier&gt;() {});</pre><p>or
                    a LDAP
                    filter:</p><pre class="programlisting">Registration&lt;T&gt; filteredRegistrations = registrations.select("(&amp;(lang=EN)(country=US))");</pre><p>or
                    both:</p><pre class="programlisting">Registration&lt;T&gt; filteredRegistrations = registrations.select(new AnnotationLiteral&lt;AnyQualifier&gt;() {}).select("(&amp;(lang=EN)(country=US))");</pre><p>Link
                    between qualifier and LDAP filter as well as subtyped service selection are
                    explain above in service injection section.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1626"/>3.2.6.3. Registration usages</h4></div></div></div><p>A registration allows to obtain service
                    implementations:</p><pre class="programlisting">Service&lt;T&gt; myServiceImplementations = registrations.getServiceReference();</pre><p>And
                    it allows to unregister service
                    implementations:</p><pre class="programlisting">registrations.unregister();</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1636"/>3.2.7. Service registry</h3></div></div></div><p>CDI-OSGi offers another way to deal with services: the service registry. It can be
                obtained in any bean bundle as a injected bean. The service registry allows
                developers to dynamically register service implementation, to obtain services and
                registrations.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1641"/>3.2.7.1. First get the service registry</h4></div></div></div><p>First get the service registry:
                    </p><pre class="programlisting">@Inject ServiceRegistry registry;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1648"/>3.2.7.2. Register a service implementation</h4></div></div></div><p>Register a service implementation:
                    </p><pre class="programlisting">registry.registerService(MyService.class,MyServiceImpl.class);</pre><p>
                    or
                    </p><pre class="programlisting">MyServiceImpl implementation = new MyServiceImpl();
registry.registerService(MyService.class,implementation);</pre><p>It is possible to collect the corresponding registration:
                    </p><pre class="programlisting">Registration&lt;MyService&gt; registeredService = registry.registerService(MyService.class,MyServiceImpl.class);</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1662"/>3.2.7.3. Obtain a service implementations</h4></div></div></div><p>Obtain a service implementations:
                    </p><pre class="programlisting">Service&lt;MyService&gt; services = registry.getServiceReference(MyService.class);
for (MyService service : services) {
    service.doSomething();
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1669"/>3.2.7.4. Obtain registrations</h4></div></div></div><p>Obtain all registrations of a filtered or not filtered specified service:
                    </p><pre class="programlisting">Registration&lt;?&gt; registrations = registry.getRegistrations();
Registration&lt;MyService&gt; myRegistrations = registry.getRegistrations(MyService.class);
Registration&lt;MyService&gt; myFrenchRegistrations = registry.getRegistrations(MyService.class,"(lang=FR)");     </pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1676"/>3.2.8. The <code class="code">OSGiServiceUnavailableException</code> exception</h3></div></div></div><p>Because OSGi service are dynamic they might be unavailable at the time they should
                be used. On a service call if the targeted service isn't available a specific
                runtime exception is raised:
                </p><pre class="programlisting">public class OSGiServiceUnavailableException extends RuntimeException {}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1686"/>3.3. CDI-OSGi events</h2></div></div></div><p>CDI-OSGi makes heavy usage of CDI events. These events allow CDI-OSGi to do its work.
            Events are important for the running of CDI-OSGi itself but they can also be used by
            client bean bundles to perform some operations or override some normal CDI-OSGi
            behavior.</p><p>This section shows the numerous events provided by CDI-OSGi and the ways to use
            them.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1693"/>3.3.1. CDI container lifecycle events</h3></div></div></div><p>Two events inform about the state of the CDI container of every bean bundle:
                    <code class="code">BundleContainerInitialized</code> and <code class="code">BundleContainerShutdown</code>
                events.</p><p>The <code class="code">BundleContext</code> from where the event comes is sent with these
                events so developers can retrieve useful information (such as the bundle owning the
                CDI container).</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1709"/>3.3.1.1. When the container is started: <code class="code">BundleContainerInitialized</code>
                    event</h4></div></div></div><p>The <code class="code">BundleContainerInitialized</code> event is fired every time a CDI
                    container is initialized in a bean bundle. It point out that the CDI container
                    is ready to manage the bean bundle with the CDI-OSGi features.</p><p>Here the way to listen this event:
                    </p><pre class="programlisting">public void onStartup(@Observes BundleContainerInitialized event) {
    BundleContext bundleContext = event.getBundleContext();
    Bundle firingBundle = bundleContext.getBundle();
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1724"/>3.3.1.2. When the container is stopped: <code class="code">BundleContainerShutdown</code>
                    event</h4></div></div></div><p>The <code class="code">BundleContainerShutdown</code> event is fired every time a CDI
                    container is stopped in a bean bundle. It point out that the CDI container wil
                    not manage the bean bundle with CDI-OSGi anymore.</p><p>Here the way to listen this
                    event:</p><pre class="programlisting">public void onShutdown(@Observes BundleContainerShutdown event) {
    BundleContext bundleContext = event.getBundleContext();
    Bundle firingBundle = bundleContext.getBundle();
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1739"/>3.3.2. Bundle lifecycle events</h3></div></div></div><p>Ten events might be fired during a bundle lifecycle. They represent the possible
                states of a bundle and monitor the changes occurred in bundle lifecycles. These
                events carry the <code class="code">Bundle</code> object from where the event comes so developers
                can retrieve useful information (such as the bundle id).</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1747"/>3.3.2.1. Listen all bundle events: <code class="code">AbstractBundleEvent</code> event</h4></div></div></div><p>CDI-OSGi provides a way to listen all bundle events in a single method: the
                        <code class="code">AbstractBundleEvent</code> abstract class. Every bundle lifecycle
                    event is an <code class="code">AbstractBundleEvent</code> and a method allows to retrieve the
                    actual fired bundle event. All bundle states are listed in the
                        <code class="code">BundleEventType</code> enumeration. Then this event can be used as the
                    corresponding bundle event.</p><p>Here the way to listen all bundle events and to retrieve the corresponding
                    bundle
                    state:</p><pre class="programlisting">public void bundleChanged(@Observes AbstractBundleEvent event) {
    BundleEventType event.getType();
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1768"/>3.3.2.2. Listen a specific bundle event</h4></div></div></div><p>Rather than listen all bundle events and then filter the intended, it is
                    possible to choose the listened bundle event.</p><p>Here the way to listen a specific bundle
                    event:</p><pre class="programlisting">public void bindBundle(@Observes BundleInstalled event) {
    Bundle bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</pre><p>All other bundle events could be listened the same way.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1779"/>3.3.2.3. Filtering bundle events: <code class="code">BundleName</code> and
                        <code class="code">BundleVersion</code> annotations</h4></div></div></div><p>It is possible to filter the listened events depending on the bundles that are
                    concerned. This filter might cover the name or the version of the
                    bundles.</p><p>Here the way to filter bundle events on the bundle
                    names:</p><pre class="programlisting">public void bindBundle(@Observes @BundleName("com.sample.gui") BundleInstalled event) {
}</pre><p>or
                    on the bundle
                    versions:</p><pre class="programlisting">public void bindBundle(@Observes @BundleVersion("4.2.1") BundleInstalled event) {
}</pre><p>or
                    on both bundle names and
                    versions:</p><pre class="programlisting">public void bindBundle(@Observes @BundleName("com.sample.gui") @BundleVersion("4.2.1") BundleInstalled event) {
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1800"/>3.3.3. Service lifecyle events</h3></div></div></div><p>Three events might be fired during a service lifecycle. They represent the
                possible states of a service and monitor the changes occurred in service lifecycles.
                These events carry the <code class="code">BundleContext</code> object from where the event comes
                and the <code class="code">ServiceReference</code> object corresponding to the service so
                developers can retrieve useful information (such as the registering bundle) and
                acces useful actions (such as register or unregister services).</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1811"/>3.3.3.1. Listen all service events: <code class="code">AbstractServiceEvent</code> event</h4></div></div></div><p>CDI-OSGi provides a way to listen all service events in a single method: the
                        <code class="code">AbstractServiceEvent</code> abstract class. Every service lifecycle
                    event is an <code class="code">AbstractServiceEvent</code> and a method allows to retrieve
                    the actual fired service event. All service states are listed in the
                        <code class="code">ServiceEventType</code> enumeration. Then this event can be used as
                    the corresponding service event.</p><p>Here the way to listen all service events and to retrieve the corresponding
                    service
                    state:</p><pre class="programlisting">public void serviceEvent(@Observes AbstractServiceEvent event) {
    ServiceEventType event.getType();
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1832"/>3.3.3.2. When a service is published: <code class="code">ServiceArrival</code> event</h4></div></div></div><p>Rather than listen all service events and then filter the intended, it is
                    possible to choose the listened service event.</p><p>Here the way to listen a specific service event:</p><pre class="programlisting">public void bindService(@Observes ServiceArrival event) {
    ServiceReference serviceReference = event.getRef();
    Bundle registeringBundle = event.getRegisteringBundle();
}</pre><p>All
                    other bundle events could be listened the same way.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1846"/>3.3.3.3. Filtering service events: <code class="code">Specification</code> and <code class="code">Filter</code>
                    annotations</h4></div></div></div><p>It is possible to filter the listened events depending on the services that
                    are concerned. This filter might cover the service specification class or it
                    might be a LDAP filter.</p><p>Here the way to filter service events on the specification
                    class:</p><pre class="programlisting">public void bindService(@Observes @Specification(MyService.class) ServiceArrival event) {
}</pre><p>or
                    using a LDAP
                    filter:</p><pre class="programlisting">public void bindService(@Observes @Specification(MyService.class) ServiceArrival event) {
}</pre><p>or
                    on both specification class and LDAP
                    filter:</p><pre class="programlisting">public void bindService(@Observes @Specification(MyService.class) @Filter("(&amp;(lang=EN)(country=US))") ServiceArrival event) {
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1867"/>3.3.4. Application dependency validation events</h3></div></div></div><p>Some bean bundle might declare required dependencies on services (using the
                    <code class="code">Required</code> annotation). CDI-OSGi fired events when these required
                dependencies are all validated or when at least one is invalidated. It allows
                application to be automatically started or stopped.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1875"/>3.3.4.1. When all dependencies are validated: <code class="code">Valid</code> event</h4></div></div></div><p>An event is fired every time all the required dependencies are
                    validated.</p><p>Here the way to listen this event:
                    </p><pre class="programlisting">public void validate(@Observes Valid event) {
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1887"/>3.3.4.2. When at least one dependency is invalidated: <code class="code">Invalid</code>
                    event</h4></div></div></div><p>An event is fired every time at least one of the required dependencies is
                    invalidated.</p><p>Here the way to listen this event:
                    </p><pre class="programlisting">public void invalidate(@Observes Invalid event) {
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1899"/>3.3.5. Intra and inter bundles communication events</h3></div></div></div><p>CDI-OSGi provides a way to communicate within and between bean bundles. This
                communication occurs in a totally decoupled manner using CDI events.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1904"/>3.3.5.1. Firing a bundle communication event: <code class="code">InterBundleEvent</code>
                    event</h4></div></div></div><p>An <code class="code">InterBundleEvent</code> is a message containing a object and
                    transmitted using CDI event.</p><p>Here the way to fire such an
                    event:</p><pre class="programlisting">@Inject Event&lt;InterBundleEvent&gt; event;
MyMessage myMessage = new MyMessage();
event.fire(new InterBundleEvent(myMessage));</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1919"/>3.3.5.2. When a bundle communication is received: <code class="code">InterBundleEvent</code>
                    event</h4></div></div></div><p>When an <code class="code">InterBundleEvent</code> is fired it might be catch either within
                    the bundle or in other bundles or both.</p><p>Here the way to receive a communication event from within the
                    bundle:</p><pre class="programlisting">public void listenAllEvents(@Observes InterBundleEvent event) {
}</pre><p>Here the way to receive a communication event from another
                    bundles:</p><pre class="programlisting">public void listenAllEventsFromOtherBundles(@Observes @Sent InterBundleEvent event) {
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1938"/>3.3.5.3. Filtering communication events: <code class="code">Specification</code> annotation</h4></div></div></div><p>It is possible to filter the listened events depending on the message type.
                    This filter may specify the type of message that is listened.</p><p>Here the way to filter communication events specifying a message type:
                    </p><pre class="programlisting">public void listenStringEventsFromOtherBundles(@Observes @Sent @Specification(MyMessage.class) InterBundleEventevent) {
}</pre><p>Only
                    the message with type <code class="code">MyMessage</code> will be received.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1954"/>3.4. OSGi utilities</h2></div></div></div><p>CDI-OSGi provide some facilities for OSGi usage. It allows to obtain, by injection,
            some of the useful objects of the OSGi environment.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1959"/>3.4.1. From the current bundle</h3></div></div></div><p>Here a way to obtain the current
                bundle:</p><pre class="programlisting">@Inject Bundle bundle;</pre><p>Here a way to obtain the current bundle
                context:</p><pre class="programlisting">@Inject BundleContext bundleContext;</pre><p>Here a way to obtain all the current bundle
                headers:</p><pre class="programlisting">@Inject @BundleHeaders Map&lt;String,String&gt;metadata;</pre><p>or
                a particular
                header</p><pre class="programlisting">@Inject @BundleHeader("Bundle-SymbolicName") String symbolicName;</pre><p>Here a way to obtain a resource file from the current
                bundle:</p><pre class="programlisting">@Injec @BundleDataFile("test.txt") File file;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1981"/>3.4.2. From external bundle</h3></div></div></div><p>Here a way to obtain a specified bundle from its name and
                version:</p><pre class="programlisting">@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") bundle;</pre><p>or
                just from its
                name:</p><pre class="programlisting">@Inject @BundleName("com.sample.gui") bundle;</pre><p>Here a way to obtain all the specified bundle
                headers:</p><pre class="programlisting">@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") @BundleHeaders Map&lt;String,String&gt;metadata;</pre><p>or
                a particular
                header:</p><pre class="programlisting">@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") @BundleHeader("Bundle-SymbolicName") String symbolicName;</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1998"/>3.5. CDI-OSGi, what else ?</h2></div></div></div><p>Here there are some examples that concretely show what CDI-OSGi is avoiding to the
            developer:</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2003"/>3.5.1. Getting service references and instances</h3></div></div></div><p>How to obtain a service available implementations list ?</p><p>In
                CDI-OSGI:</p><pre class="programlisting"><span class="bold"><strong>@Inject</strong></span> Service&lt;MyService&gt; references;</pre><p>versus
                in classic OSGi:
                </p><pre class="programlisting">ServiceReference references = <span class="bold"><strong>bundleContext.getServiceReferences(MyService.class.getName());</strong></span>
//Current BundleContext must be known</pre><p>How to obtain a service instance ?</p><p>In
                CDI-OSGi:</p><pre class="programlisting"><span class="bold"><strong>@Inject @OSGiService</strong></span> MyService service;</pre><p>versus
                in classic
                OSGi:</p><pre class="programlisting"><span class="bold"><strong>ServiceReference reference = bundleContext.getServiceReference(MyService.class.getName());</strong></span>
MyService service = <span class="bold"><strong>(MyService) bundleContext.getService(reference);</strong></span>
//Current BundleContext must be known</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2036"/>3.5.2. Publishing a service implementation</h3></div></div></div><p>How to publish a new service implementation ?</p><p>In CDI-OSGi:
                </p><pre class="programlisting"><span class="bold"><strong>@Publish</strong></span>
public class MyServiceImpl implements MyService {

    @Override
    void doSomething() {...}
}</pre><p>versus
                in classic OSGi:
                </p><pre class="programlisting">public class MyServiceImpl implements MyService {

    @Override
    void doSomething() {...}
}

<span class="bold"><strong>{ //in another class
    ServiceRegistration registration = bundleContext.registerService(MyService.class, new MyServiceImpl(), null);
}</strong></span>
//Current BundleContext must be known</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2053"/>3.5.3. Obtaining the <code class="code">Bundle</code>s and <code class="code">BundleContext</code>s</h3></div></div></div><p>How to obtain the current <code class="code">Bundle</code> ?</p><p>In
                CDI-OSGi:</p><pre class="programlisting"><span class="bold"><strong>@Inject</strong></span> Bundle currentBundle;</pre><p>versus
                in classic
                OSGi:</p><pre class="programlisting">Bundle currentBundle = <span class="bold"><strong>FrameworkUtil.getBundle(this.getClass());</strong></span></pre><p>How to obtain the current <code class="code">BundleContext</code> ?</p><p>In
                CDI-OSGi:</p><pre class="programlisting"><span class="bold"><strong>@Inject</strong></span> BundleContext bundleContext;</pre><p>versus
                in classic
                OSGi:</p><pre class="programlisting">BundleContext bundleContext = <span class="bold"><strong>FrameworkUtil.getBundle(this.getClass()).getBundleContext();</strong></span></pre><p>How to obtain a specified <code class="code">Bundle</code> and <code class="code">BundleContext</code>
                ?</p><p>In CDI-OSGi:
                </p><pre class="programlisting"><span class="bold"><strong>@Inject @BundleNamer("symbolicName") @BundleVersion("version")</strong></span> Bundle specifiedBundle;
<span class="bold"><strong>@Inject @BundleNamer("symbolicName") @BundleVersion("version")</strong></span> BundleContext specifiedBundleContext;</pre><p>versus
                in classic
                OSGi:</p><pre class="programlisting"><span class="bold"><strong>ServiceReference reference = bundleContext.getServiceReference(PackageAdmin.class.getName());
PackageAdmin packageAdmin = bundleContext.getService(reference);</strong></span>
Bundle specifiedBundle = <span class="bold"><strong>packageAdmin.getBundles("symbolicName","version")[0];</strong></span>
BundleContext specifiedBundleContext = <span class="bold"><strong>specifiedBundle.getBundleContext();</strong></span>
//Current BundleContext must be known</pre></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="ch02.html"><strong>Prev</strong>Chapter 2. Organization of CDI-OSGi</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="ch04.html"><strong>Next</strong>Chapter 4. Weld-OSGi implementation</a></li></ul></body></html>