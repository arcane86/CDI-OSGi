<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">CDI OSGi integration</title><link rel="stylesheet" href="css/seamframework-single.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/></head><body><div class="book" lang="en-US"><div class="titlepage"><div><p id="title"><a href="http://www.seamframework.org" class="site_href"><strong>SeamFramework.org</strong></a><a href="http://www.seamframework.org/Documentation" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e1"/>CDI OSGi integration</h1></div><div><h2 class="subtitle">Design Specification</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Mathieu</span> <span class="surname">Ancelin</span></h3><code class="email">&lt;<a class="email" href="mailto:mathieu.ancelin@serli.com">mathieu.ancelin@serli.com</a>&gt;</code></div><div class="author"><h3 class="author"><span class="firstname">Matthieu</span> <span class="surname">Clochard</span></h3><code class="email">&lt;<a class="email" href="mailto:matthieu.clochard@serli.com">matthieu.clochard@serli.com</a>&gt;</code></div><div class="author"><h3 class="author"><span class="firstname">Kevin</span> <span class="surname">Pollet</span></h3><code class="email">&lt;<a class="email" href="mailto:kevin.pollet@serli.com">kevin.pollet@serli.com</a>&gt;</code></div></div></div></div><hr/></div><div class="toc"><dl><dt><span class="chapter"><a href="#d0e29">1. Preface</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e32">1.1. About naming and references</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e35">1.1.1. Bean archive</a></span></dt><dt><span class="section"><a href="#d0e45">1.1.2. OSGi bundle</a></span></dt><dt><span class="section"><a href="#d0e55">1.1.3. Bean bundle</a></span></dt><dt><span class="section"><a href="#d0e68">1.1.4. References</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e73">1.2. What are CDI-OSGi and Weld-OSGi ?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e76">1.2.1. CDI-OSGi</a></span></dt><dt><span class="section"><a href="#d0e85">1.2.2. Weld-OSGi</a></span></dt><dt><span class="section"><a href="#d0e92">1.2.3. Organization and interactions between CDI-OSGi bundles</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e133">1.3. What about other frameworks</a></span></dt><dt><span class="section"><a href="#d0e140">1.4. Organization of this document</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d0e153">2. Organization of CDI-OSGi</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e156">2.1. API bundles, extension bundle and integration bundle</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e173">2.1.1. Extension API, integration API and CDI API</a></span></dt><dt><span class="section"><a href="#d0e223">2.1.2. Extension bundle: the puppet master</a></span></dt><dt><span class="section"><a href="#d0e234">2.1.3. Integration bundle: choose a CDI compliant container</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e241">2.2. An OSGi extension for CDI support: the extension API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e244">2.2.1. CDI-OSGi features</a></span></dt><dt><span class="section"><a href="#d0e267">2.2.2. The interfaces</a></span></dt><dt><span class="section"><a href="#d0e412">2.2.3. The events</a></span></dt><dt><span class="section"><a href="#d0e740">2.2.4. The annotations</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1063">2.3. A standard bootstrap for CDI container integration: the integration API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1066">2.3.1. Why an integration API</a></span></dt><dt><span class="section"><a href="#d0e1168">2.3.2. Integration bundle discovery and CDI-OSGi start</a></span></dt><dt><span class="section"><a href="#d0e1179">2.3.3. Embedded mode</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1184">2.4. An orchestrator: the extension bundle</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1187">2.4.1. The extender pattern</a></span></dt><dt><span class="section"><a href="#d0e1192">2.4.2. The extension bundle works that way:</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1200">2.5. A interchangeable CDI container factory: the integration bundle</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1207">2.5.1. A implementation bundle may work that way:</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1215">2.6. The life of a bean bundle</a></span></dt><dt><span class="section"><a href="#d0e1230">2.7. How to make a bundle or a bean archive a bean bundle</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1258">2.7.1. The META-INF/bean.xml file </a></span></dt><dt><span class="section"><a href="#d0e1271">2.7.2. The Embedded-CDIContainer META-INF/Manifest.MF header </a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e1282">3. How to make OSGi easy peasy</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1285">3.1. CDI usage in bean bundles</a></span></dt><dt><span class="section"><a href="#d0e1292">3.2. Injecting easiness in OSGi world</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1305">3.2.1. Service, implementation, instance and registration</a></span></dt><dt><span class="section"><a href="#d0e1318">3.2.2. OSGi services injection</a></span></dt><dt><span class="section"><a href="#d0e1369">3.2.3. OSGi service automatic publishing with @Publish annotation </a></span></dt><dt><span class="section"><a href="#d0e1405">3.2.4. Clearly specify a service implementation</a></span></dt><dt><span class="section"><a href="#d0e1563">3.2.5. Contextual services</a></span></dt><dt><span class="section"><a href="#d0e1584">3.2.6. The registration</a></span></dt><dt><span class="section"><a href="#d0e1636">3.2.7. Service registry</a></span></dt><dt><span class="section"><a href="#d0e1676">3.2.8. The OSGiServiceUnavailableException exception</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1686">3.3. CDI-OSGi events</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1693">3.3.1. CDI container lifecycle events</a></span></dt><dt><span class="section"><a href="#d0e1739">3.3.2. Bundle lifecycle events</a></span></dt><dt><span class="section"><a href="#d0e1800">3.3.3. Service lifecyle events</a></span></dt><dt><span class="section"><a href="#d0e1867">3.3.4. Application dependency validation events</a></span></dt><dt><span class="section"><a href="#d0e1899">3.3.5. Intra and inter bundles communication events</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1954">3.4. OSGi utilities</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1959">3.4.1. From the current bundle</a></span></dt><dt><span class="section"><a href="#d0e1981">3.4.2. From external bundle</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1998">3.5. CDI-OSGi, what else ?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2003">3.5.1. Getting service references and instances</a></span></dt><dt><span class="section"><a href="#d0e2036">3.5.2. Publishing a service implementation</a></span></dt><dt><span class="section"><a href="#d0e2053">3.5.3. Obtaining the Bundles and BundleContexts</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d0e2122">4. Weld-OSGi implementation</a></span></dt></dl></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e29"/>Chapter 1. Preface</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e32">1.1. About naming and references</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e35">1.1.1. Bean archive</a></span></dt><dt><span class="section"><a href="#d0e45">1.1.2. OSGi bundle</a></span></dt><dt><span class="section"><a href="#d0e55">1.1.3. Bean bundle</a></span></dt><dt><span class="section"><a href="#d0e68">1.1.4. References</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e73">1.2. What are CDI-OSGi and Weld-OSGi ?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e76">1.2.1. CDI-OSGi</a></span></dt><dt><span class="section"><a href="#d0e85">1.2.2. Weld-OSGi</a></span></dt><dt><span class="section"><a href="#d0e92">1.2.3. Organization and interactions between CDI-OSGi bundles</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e133">1.3. What about other frameworks</a></span></dt><dt><span class="section"><a href="#d0e140">1.4. Organization of this document</a></span></dt></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e32"/>1.1. About naming and references</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e35"/>1.1.1. Bean archive</h3></div></div></div><p>A bean archive is a java archive, such as a jar or a Java EE module, that contains
                a special marker file:<code class="code">META-INF/bean.xml</code>.</p><p>A bean archive may be deployed in a CDI environment. It enables all CDI features
                for that bean archive.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e45"/>1.1.2. OSGi bundle</h3></div></div></div><p>A bundle is a Java archive, such as a jar or a folder, that contains some special
                OSGi marker headers in its <code class="code"> META-INF/Manifest.MF</code>.</p><p>A bundle may be deployed in an OSGi environment. It enables all OSGi features for
                that bundle.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e55"/>1.1.3. Bean bundle</h3></div></div></div><p>A bean bundle is a java archive that contains both special marker file
                    <code class="code">META-INF/bean.xml</code> and special OSGi marker headers in
                    its<code class="code">META-INF/Manifest.MF</code>.</p><p>A bean bundle may be deployed in an OSGi environment with CDI-OSGi and then be
                managed by the CDI-OSGi. It enables both OSGi and CDI features for that bean
                bundle.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e68"/>1.1.4. References</h3></div></div></div><p>This document uses both CDI and OSGi specification documentations as technical
                references. You may refer to these documents for a better understanding of CDI and
                OSGi functionality, references and naming conventions.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e73"/>1.2. What are CDI-OSGi and Weld-OSGi ?</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e76"/>1.2.1. CDI-OSGi</h3></div></div></div><p>CDI-OSGi aims at simplifying application development in an OSGi environment by
                providing a more modern, more user-friendly and more simple way to interact with the
                OSGi Framework.</p><p>It addresses the OSGi complexity about services management using CDI specification
                (JSR-299). Thus it provides a CDI OSGi extension with injection utilities for the
                OSGi environment. An integration of any CDI implementation, such as Weld, is used.
                This integration is possible through a well-defined bootstrapping API.</p><p>CDI-OSGi is a framework that may be used in an OSGi environment and composed by
                five bundles.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e85"/>1.2.2. Weld-OSGi</h3></div></div></div><p>Weld-OSGi is an integration of Weld in the OSGi environment using CDI-OSGi. It is
                the exhibit implementation of features exposes by CDI-OSGi APIs.</p><p>Weld-OSGi is one of the five bundles composing CDI-OSGi. But it also names the
                framework CDI-OSGi using this particular CDI integration.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e92"/>1.2.3. Organization and interactions between CDI-OSGi bundles</h3></div></div></div><div class="figure"><a id="d0e95"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="file:/home/matthieu/Documents/CDI-OSGi/weld-osgi/cdi-osgi-design/target/docbook/staging/images/../images/CDI-OSGibundlesorganization.png" align="middle" alt="The five bundles of CDI-OSGi"/><div class="caption">This figure shows the five bundles of CDI-OSGi and the links between
                        them. Each is described below.</div></div></div><p class="title"><b>Figure 1.1. The five bundles of CDI-OSGi</b></p></div><br class="figure-break"/><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e103"/>1.2.3.1. CDI-OSGi extension</h4></div></div></div><p>The blue part represents the CDI OSGi extension. It is composed of one API
                    bundle and its implementation. It is the core of CDI-OSGi that manages all bean
                    bundles.</p><p>Thus the extension API bundle exposes the CDI-OSGi features and the extension
                    bundle enables these features. All interactions with client bundles go through
                    the CDI-OSGi extension part.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e110"/>1.2.3.2. CDI-OSGi integration</h4></div></div></div><p>The yellow part represents the CDI OSGi integration. It is composed of one API
                    bundle and its implementation. It is how CDI features are provided to
                    CDI-OSGi.</p><p>Thus the integration API bundle exposes the requirements of CDI-OSGi in order
                    to run CDI features in OSGi environment and the integration bundle is the
                    implementation of these requirements using a vendor specific CDI implementation
                    (such as Weld).</p><p>Weld-OSGi is one of the possible extension bundles. So the extension bundle is
                    commutable to support various CDI implementations.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e119"/>1.2.3.3. CDI API bundle</h4></div></div></div><p>The fifth bundle is the CDI API. It exposes regular CDI features for all client
                    bundles and exempts the user to load CDI API by himself. It is a third-party API
                    provided for convenience to the user.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e124"/>1.2.3.4. Interaction between bundles</h4></div></div></div><p>User client bean bundles should only know about the extension API bundle and
                    the CDI API bundle because they may import their packages in order to use
                    CDI-OSGi features. They do not need to know the other three bundles.</p><p>The extension bundle manages bean bundles transparently. It also implements
                    the extension API and uses the container factory service from the integration
                    bundle.</p><p>Integration API bundle should only be known by users who want to provide an
                    alternative integration bundle. This latter provides the CDI compliant containers
                    used by the extension bundle. The CDI-OSGi integration part is only used
                    internally.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e133"/>1.3. What about other frameworks</h2></div></div></div><p>CDI-OSGi stays compliant with CDI specifications and uses only standard OSGi
            mechanisms. Every things it does (or nothing from it) CDI or OGSi can do.</p><p>Thereby it is compatible with most of the current frameworks dealing with OSGi service
            management.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e140"/>1.4. Organization of this document</h2></div></div></div><p>Since this specification covers two different (but linked) pieces of software it is
            separated into two majors parts : </p><div class="itemizedlist"><ul><li><p> The CDI-OSGi specifications for core functionality usages and CDI
                        container integration. </p></li><li><p> The Weld-OSGi specifications for Weld integration into CDI-OSGi. </p></li></ul></div><p>
        </p></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e153"/>Chapter 2. Organization of CDI-OSGi</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e156">2.1. API bundles, extension bundle and integration bundle</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e173">2.1.1. Extension API, integration API and CDI API</a></span></dt><dt><span class="section"><a href="#d0e223">2.1.2. Extension bundle: the puppet master</a></span></dt><dt><span class="section"><a href="#d0e234">2.1.3. Integration bundle: choose a CDI compliant container</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e241">2.2. An OSGi extension for CDI support: the extension API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e244">2.2.1. CDI-OSGi features</a></span></dt><dt><span class="section"><a href="#d0e267">2.2.2. The interfaces</a></span></dt><dt><span class="section"><a href="#d0e412">2.2.3. The events</a></span></dt><dt><span class="section"><a href="#d0e740">2.2.4. The annotations</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1063">2.3. A standard bootstrap for CDI container integration: the integration API</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1066">2.3.1. Why an integration API</a></span></dt><dt><span class="section"><a href="#d0e1168">2.3.2. Integration bundle discovery and CDI-OSGi start</a></span></dt><dt><span class="section"><a href="#d0e1179">2.3.3. Embedded mode</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1184">2.4. An orchestrator: the extension bundle</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1187">2.4.1. The extender pattern</a></span></dt><dt><span class="section"><a href="#d0e1192">2.4.2. The extension bundle works that way:</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1200">2.5. A interchangeable CDI container factory: the integration bundle</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1207">2.5.1. A implementation bundle may work that way:</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1215">2.6. The life of a bean bundle</a></span></dt><dt><span class="section"><a href="#d0e1230">2.7. How to make a bundle or a bean archive a bean bundle</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1258">2.7.1. The META-INF/bean.xml file </a></span></dt><dt><span class="section"><a href="#d0e1271">2.7.2. The Embedded-CDIContainer META-INF/Manifest.MF header </a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e156"/>2.1. API bundles, extension bundle and integration bundle</h2></div></div></div><p>CDI-OSGi is composed of five bundles: </p><div class="itemizedlist"><ul><li><p>The three API bundles that provide the API used to define both utilities
                        provided and hooking up system with integration bundle,</p></li><li><p>The extension bundle that provides CDI-OSGi features for bean bundles by
                        managing them,</p></li><li><p>An integration bundle that provides CDI features usable by the extension
                        bundle through an OSGi service.</p></li></ul></div><p>Note that as CDI-OSGi runs in an OSGi environment it is implicit that there is an OSGi
            core bundle too. This one provide OSGi features for all other bundles, including
            CDI-OSGi managed bundles. But it is not an actual part of CDI-OSGi.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e173"/>2.1.1. Extension API, integration API and CDI API</h3></div></div></div><p>Three API bundles expose all packages that could be needed by developers; both for
                client applications using CDI-OSGi and for CDI compliant container integration.
                Their packages may be imported by bean bundles, extension bundle or implementation
                bundle.</p><p>These three distinct API are: </p><div class="itemizedlist"><ul><li><p>The extension API that describes all the new features provided by
                            CDI-OSGi in the OSGi environment.</p></li><li><p>The integration API that describes how CDI compliant containers may be
                            used by CDI-OSGi.</p></li><li><p>The CDI API that describes all the regular CDI features provided by
                            CDI-OSGi to bean bundles.</p></li></ul></div><p>These three API are more described below.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e192"/>2.1.1.1. Extension API</h4></div></div></div><p>The extension API defines all the features provided to OSGi environment using
                    CDI specifications. It exposes all the new utilities and defines the comportment
                    of the extension bundle.</p><p>It exposes all the interfaces, events and annotations usable by a developers
                    in order to develop its client bean bundles. It defines the programming model of
                    CDI-OSGi client bean bundles. Mostly it is about publishing and consuming
                    injectable services in a CDI way.</p><p>It also describes what the extension bundle needs to orchestrate bean
                    bundles.</p><p>So this is where to search for new usages of OSGi.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e203"/>2.1.1.2. Integration API</h4></div></div></div><p>The integration API defines how a CDI container, such as Weld, should
                    bootstrap with the CDI OSGi extension. So any CDI environment implementation
                    could use the CDI OSGi extension transparently. The CDI compliant container may
                    be provided using an integration bundle.</p><p>This aims at providing the minimum integration in order to start a CDI
                    compliant container with every managed bean bundle. Then the extension bundle
                    can get a CDI container for each of its managed bean bundles.</p><p>Moreover the integration API allows to mix CDI implementations in the same
                    application by providing an embedded mode. In this mode a bean bundle is
                    decoupled from the extension bundle and is managed on its own. Thus various
                    implementations of CDI container can be used and the behavior of a particular
                    bean bundle can be particularized.</p><p>All this bootstrapping mechanism works using the service layer of OSGi. An
                    integration bundle may provide a service that allows the extension bundle to
                    obtain a new container for every bean bundle.</p><p>So this is where to search to make CDI-OSGi use a specific CDI compliant
                    container.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e216"/>2.1.1.3. CDI API</h4></div></div></div><p>The CDI API is described by the CDI specifications. It is provided with
                    CDI-OSGi and defines all the CDI features usable in bean bundles.</p><p>This API will not be describe furthermore as it would be redundant with CDI
                    specifications.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e223"/>2.1.2. Extension bundle: the puppet master</h3></div></div></div><p>The extension bundle is the orchestrator of CDI-OSGi. It may be use by any
                application that requires CDI-OSGi. It may be just started with OSGi environment. It
                requests the extension API bundle as a dependency.</p><p>The extension bundle is the heart of CDI-OSGi application. Once it is started,
                provided that it finds a started integration bundle, it manages all the bean
                bundles. It is in charge of service automatic publishings, service injections, CDI
                event notifications and bundle communications. It runs in background, everything is
                transparent to the user. Client bean bundles do not have to do anything in order to
                use CDI-OSGi functionality.</p><p>In order to perform injections the extension bundle search for a CDI container
                factory service once it is started. Thus it can only work coupled with a bundle
                providing such a service: an integration bundle.</p><p>So this is where the magic happens and where OSGi applications become much more
                simple.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e234"/>2.1.3. Integration bundle: choose a CDI compliant container</h3></div></div></div><p>The integration bundle is responsible for providing CDI compliant containers to
                the extension bundle. It may be started with the extension bundle and publish a CDI
                container factory service. It requests the integration API bundle as a
                dependency.</p><p>It is an implementation of the integration API but it can use any CDI
                implementation in order to fulfill it. So this bundle might not be unique but exist
                for each vendor specific CDI implementation (such as Weld).</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e241"/>2.2. An OSGi extension for CDI support: the extension API</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e244"/>2.2.1. CDI-OSGi features</h3></div></div></div><p>As an extension to OSGi, CDI-OSGi provides several features : </p><div class="itemizedlist"><ul><li><p>Complete integration with OSGi world by the use of extender pattern
                            and extension bundle. Thus complete compatibility with already existing
                            tools.</p></li><li><p>Non intruding, configurable and customizable behavior in new or
                            upgraded application. Simple configuration and usage with annotations,
                            completely xml free.</p></li><li><p>Full internal CDI support for bean bundles: injection, producers,
                            interceptors, decorators ...</p></li><li><p>Lot of ease features for OSGi usages: injectable services, event
                            notifications, inter-bundle communication ...</p></li><li><p>OSGi and CDI compliance all along the way ensuring compatibility with
                            all CDI compliant container and easy application realisation or
                            portage.</p></li></ul></div><p>We will see in the next sections these features in deep through the description of
                the extension API.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e267"/>2.2.2. The interfaces</h3></div></div></div><p>Extension API provides few interfaces that describe all specifics about OSGi
                service injection.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e272"/>2.2.2.1. The <code class="code">Service</code> interface</h4></div></div></div><pre class="programlisting">public interface Service&lt;T&gt; extends Iterable&lt;T&gt; {

    T get();    
    Service&lt;T&gt; select(Annotation... qualifiers);
    Service&lt;T&gt; select(String filter);
    boolean isUnsatisfied();
    boolean isAmbiguous();
    int size();
}</pre><p>It represents a service instance producer parametrized by the service to
                    inject. It has the same behavior than CDI <code class="code">Instance&lt;T&gt;</code> except
                    that it represents only OSGi service beans.</p><p>IT allows to:</p><div class="itemizedlist"><ul><li><p>Wrap a list of potential service implementations as an
                                    <code class="code">Iterable</code> java object,</p></li><li><p>Select a subset of these service implementations filtered by
                                    <code class="code">Qualifier</code>s or LDAP filters,</p></li><li><p>Iterate through these service implementations,</p></li><li><p>Obtain an instance of the first remaining service
                                implementations,</p></li><li><p>Obtain utility information about the contained service
                                implementations.</p></li></ul></div><p>OSGi services should not be subtyped.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e311"/>2.2.2.2. The <code class="code">Registration</code> interface</h4></div></div></div><pre class="programlisting">public interface Registration&lt;T&gt; extends Iterable&lt;Registration&lt;T&gt;&gt; {

    void unregister();
    &lt;T&gt; Service&lt;T&gt; getServiceReference();
    Registration&lt;T&gt; select(Annotation... qualifiers);
    Registration&lt;T&gt; select(String filter);
    int size();
}
            </pre><p>This interface represents the registrations of an injectable service in the
                    service registry. Its behavior is similar to <code class="code">Service&lt;T&gt;</code>, thus it
                    might represent the iterable set of all the registrations of a service.</p><p>It allows to:</p><div class="itemizedlist"><ul><li><p>Wrap a list of service registration (i.e. the bindings between a
                                service and its implementations) as an <code class="code">Iterable</code> java
                                object,</p></li><li><p>Select a subset of these registration filtered by
                                    <code class="code">Qualifier</code>s or LDAP filters,</p></li><li><p>Iterate through these service registrations,</p></li><li><p>Obtain the service implementations list as a
                                    <code class="code">Service&lt;T&gt;</code>,</p></li><li><p>Get the number of registrations (i.e the number of registered
                                service implementations).</p></li></ul></div><p>OSGi services should not be subtyped.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e353"/>2.2.2.3. The <code class="code">RegistrationHolder</code> interface</h4></div></div></div><p>
                    </p><pre class="programlisting">public interface RegistrationHolder {

    List&lt;ServiceRegistration&gt; getRegistrations();
    void addRegistration(ServiceRegistration reg);
    void removeRegistration(ServiceRegistration reg);
    void clear();
    int size();
}</pre><p>
                </p><p>This interface represents the bindings between a service and its registered
                    implementations. It is used by <code class="code">Registration</code> to maintain the list of
                    registration bindings. It uses OSGi <code class="code">ServiceRegistration</code>.</p><p>It allows to:</p><div class="itemizedlist"><ul><li><p>Wrap a list of <code class="code">ServiceRegistration</code> as binding between
                                a service and its implementations as a <code class="code">List</code>,</p></li><li><p>Handle this list with addition, removal, clearing and size
                                operations.</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e387"/>2.2.2.4. The <code class="code">ServiceRegistry</code> interface</h4></div></div></div><pre class="programlisting">public interface ServiceRegistry {

    &lt;T&gt; Registration&lt;T&gt; registerService(Class&lt;T&gt; contract, Class&lt;? extends T&gt; implementation);
    &lt;T, U extends T&gt; Registration&lt;T&gt; registerService(Class&lt;T&gt; contract, U implementation);
    &lt;T&gt; Service&lt;T&gt; getServiceReferences(Class&lt;T&gt; contract);
}</pre><p>This interface represents a service registry where all OSGi services may be
                    handled.</p><p>It allows to:</p><div class="itemizedlist"><ul><li><p>Register a service implementation with a service, getting back the
                                corresponding <code class="code">Registration</code>,</p></li><li><p>Obtain the service implementations list as a
                                    <code class="code">Service&lt;T&gt;</code>.</p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e412"/>2.2.3. The events</h3></div></div></div><p>Extension API provides numerous events that notify about life-cycle steps for CDI
                container management, service management, bundle management, bean bundle validation
                and bundle communication management. They all use CDI event system.</p><p>CDI container events, as well as service and bundle events, are regrouped using
                three classes. Thus each category of event has: </p><div class="itemizedlist"><ul><li><p>An abstract class representing all the events of this category,
                            defining the global comportment and allowing to handle all the lifecycle
                            steps in one operation,</p></li><li><p>An enumeration describing the list of possible event types, allowing
                            to discriminate a particular lifecycle step of the category,</p></li><li><p>A list of implementation class for each of the above type, allowing to
                            handle a particular lifecycle step only. These implementation classes
                            are regrouped as static inner classes of a global category event
                            class.</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e429"/>2.2.3.1. The bundle events</h4></div></div></div><p>The representing abstract class:
                    </p><pre class="programlisting">public abstract class AbstractBundleEvent {

    private final Bundle bundle;

    public AbstractBundleEvent(Bundle bundle) {...}
    
    public abstract BundleEventType getType();
    public long getBundleId() {...}
    public String getSymbolicName() {...}
    public Version getVersion() {...}
    public Bundle getBundle() {...}
}</pre><p>This abstract class represents all the CDI-OSGi bundle events as a
                    superclass.</p><p>It allows to:</p><div class="itemizedlist"><ul><li><p>Represent all bundle events,</p></li><li><p>Retrieve the current event type as a
                                <code class="code">BundleEventType</code>,</p></li><li><p>Retrieve the firing bundle and its information.</p></li></ul></div><p>It may be used in <code class="code">Observes</code> method in order to listen all bundle
                    events.</p><p>The possible event types:
                    </p><pre class="programlisting">public enum BundleEventType {

    INSTALLED,
    LAZY_ACTIVATION,
    RESOLVED,
    STARTED,
    STARTING,
    STOPPED,
    STOPPING,
    UNINSTALLED,
    UNRESOLVED,
    UPDATED,
}</pre><p>This enumeration lists all possible states of a bundle and the corresponding
                    event types.</p><p>The implementation classes (in the global event class):
                    </p><pre class="programlisting">public class BundleEvents {

    public static class BundleInstalled extends AbstractBundleEvent {

        public BundleInstalled(Bundle bundle) {...}

        @Override
        public BundleEventType getType() {...}
    }
    //next classes follow the same template as above
    public static class BundleLazyActivation extends AbstractBundleEvent {...}
    public static class BundleResolved extends AbstractBundleEvent {...}
    public static class BundleStarted extends AbstractBundleEvent {...}
    public static class BundleStarting extends AbstractBundleEvent {...}
    public static class BundleStopped extends AbstractBundleEvent {...}
    public static class BundleStopping extends AbstractBundleEvent {...}
    public static class BundleUninstalled extends AbstractBundleEvent {...}
    public static class BundleUnresolved extends AbstractBundleEvent {...}
    public static class BundleUpdated extends AbstractBundleEvent {...}
}</pre><p>This class wraps all the bundle events as inner static classes. There is one
                    event class by <code class="code">BundleEventType</code>.</p><p>Each inner class allows to:</p><div class="itemizedlist"><ul><li><p>Represent a specific bundle event,</p></li><li><p>Retrieve the same information as
                                <code class="code">AbstractBundleEvent</code>.</p></li></ul></div><p>They may be used in <code class="code">Observes</code> method in order to listen a specific
                    bundle event.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e490"/>2.2.3.2. The service events</h4></div></div></div><p>The representing abstract class:
                    </p><pre class="programlisting">public abstract class AbstractServiceEvent {

    private final ServiceReference reference;
    private final BundleContext context;
    private List&lt;String&gt; classesNames;
    private List&lt;Class&lt;?&gt;&gt; classes;
    private Map&lt;Class, Boolean&gt; assignable;

    public AbstractServiceEvent(ServiceReference reference, BundleContext context) {...}
    
    public abstract ServiceEventType eventType();
    public ServiceReference getReference() {...}
    public &lt;T&gt; TypedService&lt;T&gt; type(Class&lt;T&gt; type) {...}
    public Object getService() {...}
    public boolean ungetService() {...}
    public boolean isTyped(Class&lt;?&gt; type) {...}
    public Bundle getRegisteringBundle() {...}
    public List&lt;String&gt; getServiceClassNames() {...}
    public List&lt;Class&lt;?&gt;&gt; getServiceClasses() {...}

    public static class TypedService&lt;T&gt; {

        private final BundleContext context;
        private final ServiceReference ref;
        private final Class&lt;T&gt; type;

        TypedService(BundleContext context, ServiceReference ref, Class&lt;T&gt; type) {...}
        
        static &lt;T&gt; TypedService&lt;T&gt; create(Class&lt;T&gt; type, BundleContext context, ServiceReference ref) {...}
        public T getService() {...}
        public boolean ungetService() {...}
    }
}</pre><p>This abstract class represents all the CDI-OSGi service events as a
                    superclass.</p><p>It allows to:</p><div class="itemizedlist"><ul><li><p>Represent all service events,</p></li><li><p>Retrieve the current event type as a
                                <code class="code">ServiceEventType</code>,</p></li><li><p>Retrieve the affected <code class="code">ServiceReference</code>, the
                                corresponding information and registering
                                <code class="code">Bundle</code>,</p></li><li><p>Manipulate the service,</p></li><li><p>Retrieve the firing <code class="code">BundleContext</code>.</p></li></ul></div><p>It may be used in <code class="code">Observes</code> method in order to listen all service
                    events.</p><p>The possible event types:
                    </p><pre class="programlisting">public enum ServiceEventType {

    SERVICE_ARRIVAL,
    SERVICE_DEPARTURE,
    SERVICE_CHANGED
}</pre><p>This enumeration lists all possible states of a service and the corresponding
                    event types.</p><p>The implementation classes (in the global event class):
                    </p><pre class="programlisting">public class ServiceEvents {

    public static class ServiceArrival extends AbstractServiceEvent {

        public ServiceArrival(
                ServiceReference ref, BundleContext context) {
            super(ref, context);
        }

        @Override
        public ServiceEventType eventType() {
            return ServiceEventType.SERVICE_ARRIVAL;
        }
    }
    //next classes follow the same template as above
    public static class ServiceChanged extends AbstractServiceEvent {...}
    public static class ServiceDeparture extends AbstractServiceEvent {...}

}</pre><p>This class wraps all the service events as inner static classes. There is one
                    event class by <code class="code">ServiceEventType</code>.</p><p>Each inner class allows to:</p><div class="itemizedlist"><ul><li><p>Represent a specific service event,</p></li><li><p>Retrieve the same information as
                                <code class="code">AbstractServiceEvent</code>.</p></li></ul></div><p>They may be used in <code class="code">Observes</code> method in order to listen a specific
                    service event.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e566"/>2.2.3.3. The bundle container events</h4></div></div></div><p>The representing abstract class:
                    </p><pre class="programlisting">public abstract class AbstractBundleContainerEvent {

    private BundleContext bundleContext;

    public AbstractBundleContainerEvent(final BundleContext context) {...}

    public abstract BundleContainerEventType getType();
    public BundleContext getBundleContext() {...}
}</pre><p>This abstract class represents all the CDI-OSGi bundle container events as a
                    superclass.</p><p>It allows to:</p><div class="itemizedlist"><ul><li><p>Represent all bundle container events,</p></li><li><p>Retrieve the current event type as a
                                    <code class="code">BundleContainerEventType</code>,</p></li><li><p>Retrieve the firing <code class="code">BundleContext</code>.</p></li></ul></div><p>It may be used in <code class="code">Observes</code> method in order to listen all bundle
                    container events.</p><p>The possible event types:
                    </p><pre class="programlisting">public enum BundleContainerEventType {

    INITIALIZED,
    SHUTDOWN
}</pre><p>This enumeration list all possible states of a bundle container and the
                    corresponding event types.</p><p>The implementation classes (in the global event class):
                    </p><pre class="programlisting">public class BundleContainerEvents {

    public static class BundleContainerInitialized extends AbstractBundleContainerEvent {

        public BundleContainerInitialized(BundleContext context) {
            super(context);
        }

        @Override
        public BundleContainerEventType getType() {
            return BundleContainerEventType.INITIALIZED;
        }
    }
    //next class follows the same template as above
    public static class BundleContainerShutdown extends AbstractBundleContainerEvent {...}
}</pre><p>This class wraps all the bundle container events as inner static classes.
                    There is one event class by <code class="code">BundleContainerEventType</code>.</p><p>Each inner class allows to:</p><div class="itemizedlist"><ul><li><p>Represent a specific bundle container event,</p></li><li><p>Retrieve the same information as
                                    <code class="code">AbstractBundleContainerEvent</code>.</p></li></ul></div><p>They may be used in <code class="code">Observes</code> method in order to listen a specific
                    bundle container event.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e630"/>2.2.3.4. The bean bundle validation events</h4></div></div></div><p>Two events notify about the validation of bean bundle. After it starts a bean
                    bundle should validate its required service dependencies. The <code class="code">Valid</code>
                    and <code class="code">Invalid</code> events occurs when such dependencies are fulfilled or
                    unfulfilled. These two new states are described in an enumeration:
                        <code class="code">BundleState</code>.</p><p>
                    </p><pre class="programlisting">public class Valid {

    private final Bundle bundle;

    public Valid(Bundle bundle) {...}

    public long getBundleId() {...}
    public String getSymbolicName() {...}
    public Version getVersion() {...}
    public Bundle getBundle() {...}
}</pre><p>
                </p><p>This class represents all bean bundle validation event.</p><p>It allows to:</p><div class="itemizedlist"><ul><li><p>Represent all bean bundle validation events,</p></li><li><p>Retrieve the validated bean bundle and its information.</p></li></ul></div><p>It may be used in <code class="code">Observes</code> method in order to listen all bean
                    bundle validation events.</p><p>
                    </p><pre class="programlisting">public class Invalid {

    private final Bundle bundle;

    public Invalid(Bundle bundle) {...}

    public long getBundleId() {...}
    public String getSymbolicName() {...}
    public Version getVersion() {...}
    public Bundle getBundle() {...}
}</pre><p>
                </p><p>This class represents all bean bundle invalidation event.</p><p>It allows to:</p><div class="itemizedlist"><ul><li><p>Represent all bean bundle invalidation events,</p></li><li><p>Retrieve the invalidated bean bundle and its information.</p></li></ul></div><p>It may be used in <code class="code">Observes</code> method in order to listen all bean
                    bundle invalidation events.</p><pre class="programlisting">public enum BundleState {
    VALID, INVALID
}</pre><p>This enumeration lists the two new states of a bean bundle.</p><p>A bean bundle is in <code class="code">VALID</code> state if all its required service
                    dependencies are validated otherwise is in <code class="code">INVALID</code> state. Every
                    time a bean bundle goes from one state to another a corresponding
                        <code class="code">Valid</code> or <code class="code">Invalid</code> event may be fired.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e704"/>2.2.3.5. The <code class="code">InterBundleEvent</code> event</h4></div></div></div><p>
                    </p><pre class="programlisting">public class InterBundleEvent {

    private final Object event;
    private boolean sent = false;
    private Class&lt;?&gt; type;

    public InterBundleEvent(Object event) {...}
    public InterBundleEvent(Object event, Class&lt;?&gt; type) {...}

    public Class&lt;?&gt; type() {...}
    public boolean isTyped(Class&lt;?&gt; type) {...}
    public &lt;T&gt; Provider&lt;T&gt; typed(Class&lt;T&gt; type) {...}
    public Object get() {...}
    public boolean isSent() {...}
    public void sent() {...}
}</pre><p>
                </p><p>This class represents a communication event between bean bundles.</p><p>It allows to specify: </p><div class="itemizedlist"><ul><li><p>The message as an <code class="code">Object</code>,</p></li><li><p>The type of the message as a <code class="code">Class</code>,</p></li><li><p>The origin of the message (within or outside the bundle).</p></li></ul></div><p>It may be used in <code class="code">Observes</code> method in order to listen inter-bundle
                    communications.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e740"/>2.2.4. The annotations</h3></div></div></div><p>Extension API provides annotations in order to easily use CDI-OSGi
                features.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e745"/>2.2.4.1. The <code class="code">OSGiBundle</code>, <code class="code">BundleName</code> and
                        <code class="code">BundleVersion</code> annotations</h4></div></div></div><pre class="programlisting">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface OSGiBundle {
    @Nonbinding String value();
    @Nonbinding String version() default "";
}</pre><p>This annotation qualifies an injection point that represents a bundle or a
                    bundle relative object.</p><p>It allows to specify:</p><div class="itemizedlist"><ul><li><p>The symbolic name of the bundle, as a required value,</p></li><li><p>The version of the bundle, as an optional value.</p></li></ul></div><p>The symbolic name and version are <span class="bold"><strong>not</strong></span>
                    actually qualifying the injection point, thus this annotation is for global
                    bundle injection point with additional data. In order to actually discriminate
                    on the symbolic name or version see <code class="code">BundleName</code> and
                        <code class="code">BundleVersion</code> annotations.</p><pre class="programlisting">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleName {
    String value();
}</pre><p>This annotation qualifies an injection point that represents a bundle or a
                    bundle relative object.</p><p>It allows to specify the symbolic name of the bundle, as a required
                    value.</p><p>The symbolic name actually discriminate the injection point, thus this
                    annotation is for specific bundle relative injection point. For global bundle
                    relative injection point see <code class="code">OSGiBundle</code> annotation. To discriminate
                    the bundle version see <code class="code">BundleVersion</code>.</p><pre class="programlisting">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleVersion {
    String value();
}</pre><p>This annotation qualifies an injection point that represents a bundle or a
                    bundle relative object.</p><p>It allows to specify the version of the bundle, as a required value.</p><p>The version actually discriminate the injection point, thus this annotation is
                    for specific bundle relative injection point. For global bundle relative
                    injection point see <code class="code">OSGiBundle</code> annotation. To discriminate the
                    bundle symbolic name see <code class="code">BundleName</code>.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e809"/>2.2.4.2. The <code class="code">BundleDataFile</code>, <code class="code">BundleHeader</code> and
                        <code class="code">BundleHeaders</code> annotations</h4></div></div></div><pre class="programlisting">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleDataFile {
    @Nonbinding String value();
}</pre><p>This annotation qualifies an injection point that represents a bundle data
                    file.</p><p>It allows to specify the relative path of the file in the bundle, as a
                    required value.</p><p>The file path is <span class="bold"><strong>not</strong></span> actually qualifying the
                    injection point, thus this annotation is for global bundle data file injection
                    point with additional data. To discriminate the bundle use
                        <code class="code">OSGiBundle</code> or <code class="code">BundleName</code> and
                        <code class="code">BundleVersion</code> annotations.</p><pre class="programlisting">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleHeader {
    @Nonbinding String value();
}</pre><p>This annotation qualifies an injection point that represents a specific bundle
                    header.</p><p>It allows to specify the name of the bundle header, as a required
                    value.</p><p>The header name is <span class="bold"><strong>not</strong></span> actually qualifying
                    the injection point, thus this annotation is for global specific bundle header
                    injection point with additional data. To discriminate the bundle use
                        <code class="code">OSGiBundle</code> or <code class="code">BundleName</code> and
                        <code class="code">BundleVersion</code> annotations. To obtain all the bundle headers see
                        <code class="code">BundleHeaders</code> annotations.</p><pre class="programlisting">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface BundleHeaders {
}</pre><p>This annotation qualifies an injection point that represents all headers of a
                    bundle.</p><p>To discriminate the bundle use <code class="code">OSGiBundle</code> or
                        <code class="code">BundleName</code> and <code class="code">BundleVersion</code> annotations. To
                    obtain a specific bundle header see <code class="code">BundleHeader</code> annotation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e882"/>2.2.4.3. The <code class="code">OSGiService</code> annotation</h4></div></div></div><pre class="programlisting">@Qualifier
@Target({ TYPE, METHOD, PARAMETER, FIELD })
@Retention(RetentionPolicy.RUNTIME)
public @interface OSGiService {
}</pre><p>This annotation qualifies an injection point that represents a service from
                    the OSGi service registry.</p><p>It may be use to obtain an injected OSGi service using <code class="code">Service</code>
                    interface or directly the service contract interface. The injected service might
                    be filtered using regular <code class="code">Qualifier</code> annotations or a LDAP filter
                    with <code class="code">Filter</code> annotation. It also might be mark as required for
                    bundle running using <code class="code">Required</code> annotation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e906"/>2.2.4.4. The <code class="code">Publish</code> and <code class="code">Property</code> annotations</h4></div></div></div><pre class="programlisting">@Target({ TYPE })
@Retention(RetentionPolicy.RUNTIME)
public @interface Publish {
    public Class[] contracts() default {};
    public Property[] properties() default {};
}</pre><p>This annotation notices that this type is an OSGi service implementation and
                    should be automatically published in the OSGi service registry.</p><p>It allows to specify:</p><div class="itemizedlist"><ul><li><p>The contract interfaces of implemented service, as an optional
                                array of <code class="code">Class</code>es,</p></li><li><p>The properties of the published service implementation, as an
                                optional array of <code class="code">Property</code>.</p></li></ul></div><p>The published implementation might be discriminated using regular
                        <code class="code">Qualifier</code> annotations or a LDAP filter with <code class="code">Filter</code>
                    annotation.</p><p>
                    </p><pre class="programlisting">@Retention(RetentionPolicy.RUNTIME)
public @interface Property {
    String name();
    String value();
}</pre><p>
                </p><p>This annotation wraps an OSGi service property used for automatic OSGi service
                    publishing.</p><p>It allows to specify:</p><div class="itemizedlist"><ul><li><p>The name of the property, as a required
                                <code class="code">String</code>,</p></li><li><p>The value of the property, as a required
                                <code class="code">String</code>.</p></li></ul></div><p>It may be used within the <code class="code">Publish</code> annotation to provide the
                    published service implementation properties.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e969"/>2.2.4.5. The <code class="code">Required</code> annotation</h4></div></div></div><pre class="programlisting">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface Required {
}</pre><p>This annotation qualifies an injection point that represents a required
                    service.</p><p>It may be coupled with the <code class="code">OSGiService</code> annotation in order to
                    qualify a service that must be available for the application to start.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e984"/>2.2.4.6. The <code class="code">Filter</code> annotation</h4></div></div></div><pre class="programlisting">@Qualifier
@Retention(RetentionPolicy.RUNTIME)
public @interface Filter {
    String value();
}</pre><p>This annotation qualifies an injection point that represents a LDAP filtered
                    service.</p><p>It allows to specify the LDAP filter, as a required
                    <code class="code">String</code>.</p><p>It may be coupled with a <code class="code">OSGiService</code> or a <code class="code">Publish</code>
                    annotation in order to filter the injected or published service implementations.
                    The LDAP filtering acts on <code class="code">Qualifier</code> or <code class="code">Property</code>
                    annotations or regular OSGi properties used in service publishing.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1013"/>2.2.4.7. The <code class="code">Specification</code> annotation</h4></div></div></div><pre class="programlisting">@Qualifier
@Target({ PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
public @interface Specification {
    Class value();
}</pre><p>This annotation qualifies an injection point that represents events whose
                    match one of the specifications.</p><p>It allows to specify the specification interfaces of the <code class="code">Event</code>s
                    parametrizing types, as a required <code class="code">Class</code>.</p><p>It may be used in an <code class="code">Observes</code> method to restrict the listened
                    events.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1036"/>2.2.4.8. The <code class="code">Sent</code> annotation</h4></div></div></div><pre class="programlisting">@Qualifier
@Target({ PARAMETER })
@Retention(RetentionPolicy.RUNTIME)
public @interface Sent {
}</pre><p>This annotation qualifies an injection point that represents an
                        <code class="code">InterBundleEvent</code> from outside the current
                    <code class="code">Bundle</code>.</p><p>It may be used in an <code class="code">Observes</code> method to restrict the listened
                        <code class="code">InterBundleEvent</code>. It allows to ignore the
                        <code class="code">InterBundleEvent</code> from within the current bundle.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1063"/>2.3. A standard bootstrap for CDI container integration: the integration API</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1066"/>2.3.1. Why an integration API</h3></div></div></div><p>CDI-OSGi could have been carried out with an internal CDI compliant container and
                work very well. Every one of the specifications above would have been fulfilled. But
                no other specific utilities or CDI evolution could have been added without a
                complete modification of CDI-OSGi.</p><p>Then there is the integration API. With that, developers are able to provide their
                own integration bundle. Thus it is possible to use any CDI compliant container with
                a CDI-OSGi application or mix up different CDI compliant containers for different
                bundles.</p><p>Integration API describes what needs the extension bundle to work (and therefore
                what may provide the integration bundle): </p><div class="itemizedlist"><ul><li><p>A CDI container with standard comportment and functionality,</p></li><li><p>A factory for such CDI containers initialized and ready to run.</p></li></ul></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1082"/>2.3.1.1. The <code class="code">CDIContainer</code> interface</h4></div></div></div><pre class="programlisting">public interface CDIContainer extends  Iterable&lt;CDIContainer&gt; {

    boolean initialize();
    boolean shutdown();
    boolean isStarted();
    void fire(InterBundleEvent event);
    Bundle getBundle();
    BeanManager getBeanManager();
    Event getEvent();
    Instance&lt;Object&gt; getInstance();
    Collection&lt;String&gt; getBeanClasses();
    Collection&lt;ServiceRegistration&gt; getRegistrations();
    void setRegistrations(Collection&lt;ServiceRegistration&gt; registrations);
    CDIContainer select(Bundle bundle);
    CDIContainer select(String name, String version);
    int size();
}</pre><p>This interface represents an iterable list of CDI containers used by
                    CDI-OSGi.</p><p>It allows to: </p><div class="itemizedlist"><ul><li><p>Navigate through the list of CDI containers as an
                                    <code class="code">Iterable</code>,</p></li><li><p>Obtain the number of CDI containers,</p></li><li><p>Select a specific container by its bundle,</p></li><li><p>Start and stop the selected CDI container,</p></li><li><p>Obtain the state of the selected CDI container,</p></li><li><p>Obtain the corresponding <code class="code">Bundle</code>,
                                    <code class="code">BeanManager</code>, <code class="code">Event</code>, managed bean
                                    <code class="code">Class</code> and <code class="code">Instance</code> and registred
                                service as <code class="code">ServiceRegistration</code>,</p></li><li><p>Fire <code class="code">InterBundleEvent</code>.</p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1140"/>2.3.1.2. The <code class="code">CDIContainerFactory</code> interface</h4></div></div></div><pre class="programlisting">public interface CDIContainerFactory {

    String getID();
    Set&lt;String&gt; getContractBlacklist();
    CDIContainer container(Bundle bundle);
}</pre><p>This interface represents a CDI container factory used by CDI-OSGi in order to
                    obtain <code class="code">CDIContainer</code>.</p><p>It allows to: </p><div class="itemizedlist"><ul><li><p>Obtain the CDI container of a specific bean <code class="code">Bundle</code>
                                (singleton for each bean bundle),</p></li><li><p>Provide a interface black list for service publishing,</p></li><li><p>Obtain the ID of the used CDI implementation.</p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1168"/>2.3.2. Integration bundle discovery and CDI-OSGi start</h3></div></div></div><div class="figure"><a id="d0e1171"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="file:/home/matthieu/Documents/CDI-OSGi/weld-osgi/cdi-osgi-design/target/docbook/staging/images/../images/CDI-OSGistartprotocol.png" align="middle" alt="CDI-OSGi framework start and stop protocol"/><div class="caption">This figure shows the steps of the CDI-OSGi starting and stopping
                        protocol. Between step 8 and step 11 the framework is in stable state and
                        manages bean bundles.</div></div></div><p class="title"><b>Figure 2.1. CDI-OSGi framework start and stop protocol</b></p></div><br class="figure-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1179"/>2.3.3. Embedded mode</h3></div></div></div><p>//TODO</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1184"/>2.4. An orchestrator: the extension bundle</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1187"/>2.4.1. The extender pattern</h3></div></div></div><p>CDI-OSGi provides an extension to OSGi as an extender pattern. The extension
                bundle, the extender, tracks for bean bundles, the extensions, to be started. Then
                CDI utilities are enabled for these bean bundles over OSGi environment.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1192"/>2.4.2. The extension bundle works that way:</h3></div></div></div><p>
                </p><pre class="programlisting">BEGIN
    start
    WHILE ! implementation_bundle.isStarted
        wait
    END_WHILE
    obtain_container_factory
    FOR bean_bundle : started_bundles
        manage_bean_bundle
        provide_container
    END_FOR
    WHILE implementation_bundle.isStarted
        wait_event
        OnBeanBundleStart
            manage_bean_bundle
            provide_container
        OnBeanBundleStop
            unmanage_bean_bundle
    END_WHILE
    stop
    FOR bean_bundle : namaged_bundles
        unmanage_bean_bundle
        stop_bean_bundle
    END_FOR
END</pre><p>
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1200"/>2.5. A interchangeable CDI container factory: the integration bundle</h2></div></div></div><p>The integration bundle is necessary in a CDI-OSGi application. This section explains
            the part the integration bundle plays but does not enter in specifics because it depends
            on the CDI implementation used.</p><p>Weld-OSGi chapter presents how an implementation bundle can work.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1207"/>2.5.1. A implementation bundle may work that way:</h3></div></div></div><p>
                </p><pre class="programlisting">BEGIN
    start
    register_container_factory_service
    WHILE true
        wait
        OnContainerRequest
            provide_container
    END_WHILE
    unregister_container_factory_service
END</pre><p>
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1215"/>2.6. The life of a bean bundle</h2></div></div></div><p>This section presents the lifecycle of a bean bundle and how it impacts CDI and OSGi
            regular behaviors. Mostly bean bundles follow the same lifecycle than a regular bundle.
            There are only two new possible states and they do not modify the behavior from OSGi
            side.</p><div class="figure"><a id="d0e1220"/><div class="figure-contents"><div class="mediaobject" align="center"><img src="file:/home/matthieu/Documents/CDI-OSGi/weld-osgi/cdi-osgi-design/target/docbook/staging/images/../images/Beanbundlestate.png" align="middle" alt="The bean bundle lifecycle"/><div class="caption">This figure shows the two new states a bean bundle can be in. These states
                    are triggered by two new events and address the CDI container dependency
                    resolution (i.e. services annotated @Required).</div></div></div><p class="title"><b>Figure 2.2. The bean bundle lifecycle</b></p></div><br class="figure-break"/><p>The regular OSGi lifecycle is not modified by the new CDI-OSGi states as they have the
            same meaning than the ACTIVE state from an OSGi point of view. They only add information
            about the validation of required service availability.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1230"/>2.7. How to make a bundle or a bean archive a bean bundle</h2></div></div></div><p>There are very few things to do in order to obtain a bean bundle from a bean archive
            or a bundle. Mostly it is just adding the missing marker files and headers in the
            archive: </p><div class="itemizedlist"><ul><li><p> Make a bean archive a bean bundle by adding special OSGi marker headers
                        in its <code class="code">META-INF/Manifest.MF</code> file.</p></li><li><p> Or, in the other way, make a bundle a bean bundle by adding a
                            <code class="code">META-INF/bean.xml</code> file.</p></li></ul></div><p>Thus a bean bundle has both <code class="code">META-INF/bean.xml</code> file and OSGi marker
            headers in its <code class="code">META-INF/Manifest.MF</code> file.</p><p>However there is a few other information that CDI-OSGi might need in order to perform
            a correct extension. In particular a bean bundle can not be manage by the extension
            bundle but by his own embedded CDI container. For that there is a new manifest
            header.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1258"/>2.7.1. The <code class="code">META-INF/bean.xml</code> file </h3></div></div></div><p>The beans.xml file follows no particular rules and should be the same as in a
                native CDI environment. Thus it can be completely empty or declare interceptors,
                decorators or alternatives as a regular CDI beans.xml file.</p><p>There will be no different behavior with a classic bean archive except for CDI
                OSGi extension new utilities. But these don't need any modification on the
                    <code class="code">META-INF/bean.xml</code> file.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1271"/>2.7.2. The Embedded-CDIContainer <code class="code">META-INF/Manifest.MF</code> header </h3></div></div></div><p>This header prevents the extension bundle to automatically manage the bean bundle
                that set this manifest header to true. So the bean bundle can be manage more finely
                by the user or use a different CDI container. If this header is set to false or is
                not present in the <code class="code">META-INF/Manifest.MF</code> file then the bean bundle will
                be automatically manage by the extension bundle (if it is started).</p></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1282"/>Chapter 3. How to make OSGi easy peasy</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#d0e1285">3.1. CDI usage in bean bundles</a></span></dt><dt><span class="section"><a href="#d0e1292">3.2. Injecting easiness in OSGi world</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1305">3.2.1. Service, implementation, instance and registration</a></span></dt><dt><span class="section"><a href="#d0e1318">3.2.2. OSGi services injection</a></span></dt><dt><span class="section"><a href="#d0e1369">3.2.3. OSGi service automatic publishing with @Publish annotation </a></span></dt><dt><span class="section"><a href="#d0e1405">3.2.4. Clearly specify a service implementation</a></span></dt><dt><span class="section"><a href="#d0e1563">3.2.5. Contextual services</a></span></dt><dt><span class="section"><a href="#d0e1584">3.2.6. The registration</a></span></dt><dt><span class="section"><a href="#d0e1636">3.2.7. Service registry</a></span></dt><dt><span class="section"><a href="#d0e1676">3.2.8. The OSGiServiceUnavailableException exception</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1686">3.3. CDI-OSGi events</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1693">3.3.1. CDI container lifecycle events</a></span></dt><dt><span class="section"><a href="#d0e1739">3.3.2. Bundle lifecycle events</a></span></dt><dt><span class="section"><a href="#d0e1800">3.3.3. Service lifecyle events</a></span></dt><dt><span class="section"><a href="#d0e1867">3.3.4. Application dependency validation events</a></span></dt><dt><span class="section"><a href="#d0e1899">3.3.5. Intra and inter bundles communication events</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1954">3.4. OSGi utilities</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e1959">3.4.1. From the current bundle</a></span></dt><dt><span class="section"><a href="#d0e1981">3.4.2. From external bundle</a></span></dt></dl></dd><dt><span class="section"><a href="#d0e1998">3.5. CDI-OSGi, what else ?</a></span></dt><dd><dl><dt><span class="section"><a href="#d0e2003">3.5.1. Getting service references and instances</a></span></dt><dt><span class="section"><a href="#d0e2036">3.5.2. Publishing a service implementation</a></span></dt><dt><span class="section"><a href="#d0e2053">3.5.3. Obtaining the Bundles and BundleContexts</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1285"/>3.1. CDI usage in bean bundles</h2></div></div></div><p>Everything possible in CDI applications is possible in bean bundle. They can take
            advantage of injection, producers, interceptors, decorators and alternative. But
            influence boundary of the CDI compliant container stay within the bean bundle for
            classic CDI usages. So external dependencies cannot be injected and interceptor,
            decorator or alternative of another bean bundle cannot be used (yet interceptors,
            decorators and alternatives still need to be declares in the bean bundle bean.xml file). </p><p>That is all we will say about classic CDI usages, please report to CDI documentation
            for more information.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1292"/>3.2. Injecting easiness in OSGi world</h2></div></div></div><p>CDI-OSGi provides more functionality using CDI in a OSGi environment.</p><p>It mainly focuses on the OSGi service layer. It addresses the difficulties in
            publishing and consuming services. CDI-OSGi allows developers to publish and consume
            OSGi services as CDI beans. However, since OSGi services are dynamic there are some
            differences with classic bean injection. This section presents how OSGi services can be
            published and consumed using CDI-OSGi.</p><p>CDI-OSGi also provides utilities for event notification and communication in and
            between bundles as well as some general OSGi utilities.</p><p>Examples use this very sophisticated service interface:
            </p><pre class="programlisting">public interface MyService {
    void doSomething();
}</pre><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1305"/>3.2.1. Service, implementation, instance and registration</h3></div></div></div><p>First it is important to be clear about what are a service, its implementations,
                its instances and its registrations.</p><p>A service is mostly an interface. This interface defines the contract that
                describes what the service may do. It might be several way to actually providing the
                service, thus a service might have multiple implementations.</p><p>A service implementation is a class that implements this service. It is what is
                available to other components that use the service. To use the service the component
                obtain an instance of the implementation.</p><p>A service instance is an instance of one of the service implementations. It is
                what the user manipulates to perform the service.</p><p>A registration is the object that represents a service registered with a
                particular implementation. Then this implementation can be searched and its
                instances can be obtained. Every time a service implementation his register a
                corresponding registration object is created.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1318"/>3.2.2. OSGi services injection</h3></div></div></div><p> There are two ways to obtain a service instances using CDI-OSGi: direct injection
                and programmatic lookup.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1323"/>3.2.2.1. Direct injection using <code class="code">@OSGiService</code> annotation </h4></div></div></div><p>The main way to perform an OSGi injection is to use the <code class="code">@Inject
                        @OSGiService</code> annotation combination. It acts like a common injection
                    except that CDI-OSGi will search for injectable instances in the service
                    registry.</p><p>That is how it looks like:
                    </p><pre class="programlisting">@Inject @OSGiService MyService service;
service.doSomething(); </pre><p>The behavior is similar with classic CDI injection. <code class="code">@OSGiService</code>
                    is just a special qualifier that allows extension bundle to manage the injection
                    instead of CDI implementation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1343"/>3.2.2.2. Injection using programmatic lookup</h4></div></div></div><p>Instead of obtain directly a service instance it is possible to choose between
                    service implementations and instantiate one at runtime. The interface
                        <code class="code">Service&lt;T&gt;</code> works as a service instance producer: it
                    retrieves all the corresponding (to the service parametrized type) service
                    implementations and allows to get an instance for each.</p><p>Service implementations and a corresponding instance can be obtained like
                    that:
                    </p><pre class="programlisting">@Inject Service&lt;MyService&gt; services;
services.get().doSomething();</pre><p>All
                    implementations can also be iterated like that:
                    </p><pre class="programlisting">@Inject Service&lt;MyService&gt; services;
for (MyService service : services) {
    service.get().doSomething();
}</pre><p>The
                        <code class="code">get()</code> method returns an instance of the first available service
                    implementation.</p><p><code class="code">Service&lt;T&gt;</code> acts like CDI <code class="code">Instance&lt;T&gt;</code> except
                    that the injection process is managed by the extension bundle instead of  CDI
                    implementation. So the available implementations are searched dynamically into
                    the service registry.</p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1369"/>3.2.3. OSGi service automatic publishing with <code class="code">@Publish</code> annotation </h3></div></div></div><p>CDI-OSGi allows developers to automatically publish service implementation. There
                is nothing to do, just put the annotation. OSGi framework is completely hidden. Then
                the service is accessible through CDI-OSGi service injection and OSGi classic
                mechanisms.</p><p>Automatically publish a new service implementation:
                </p><pre class="programlisting">@Publish
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}</pre><p>It
                registers a service <code class="code">MyService</code> with the implementation
                    <code class="code">MyServiceImpl</code>.</p><p>The behavior is similar with classic CDI bean registration, except that services
                are not register into the bean manager but into the service registry.</p><p>It is possible to specify the contracts interface that this specific
                implementation fulfill using the <code class="code">Publish</code> annotation.</p><p>
                </p><pre class="programlisting">@Publish(contracts = {MyService.class, MyOtherService.class})
public class MyServiceImpl {

    public void doSomething() {
    }
}</pre><p>
            </p><p>If no contract list are provided, the implementation will match each of its
                interface types. Every CDI container of a bean bundle might have a blacklist that
                excludes some interface from being register as a service type. See the specific
                integration bundle doccumentation to obtain the used blacklist. This blacklist is
                only used when no interface array is provided within the <code class="code">Publish</code>
                annotation.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1405"/>3.2.4. Clearly specify a service implementation</h3></div></div></div><p>There might be multiple implementations of the same service. It is possible to
                provide properties to an implementation in CDI-OSGi. This qualification is available
                both during publishing and consuming.</p><p>There are two ways for qualifying: a CDI like and a OSGi like, both are presented
                below.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1412"/>3.2.4.1. Using <code class="code">@Qualifier</code> annotations</h4></div></div></div><p>Qualifiers are used like in classic CDI applications. An implementation can be
                    qualified by as many qualifiers as needed. An injection point can be also
                    qualified in order to restraint the potential injected implementations. It is
                    finally possible to select the instance produced when using the
                        <code class="code">Service&lt;T&gt;</code> interface.</p><p>Qualified service publishing:
                    </p><pre class="programlisting">
@Publish
@AnyQualifier
public class MyServiceQualifiedImpl implements MyService {

    @Override
    public void doSomething() {
    }
}                </pre><p>Qualified
                    injection point:
                    </p><pre class="programlisting">
@Inject @OSGiService @AnyQualifier MyService qualifiedService; 
qualifiedService.doSomething();</pre><p>or
                    with <code class="code">Service&lt;T&gt;</code>
                    </p><pre class="programlisting">
@Inject @AnyQualifier Service&lt;MyService&gt; service;
service.get().doSomething();</pre><p>The qualifiers should be seen as the service properties. Here another example:
                    </p><pre class="programlisting">@Publish
@Lang(EN)
@Country(US)
@ApplicationScoped
public class MyServiceImpl implements MyService {

    @Override
    public void doSomething() {
    }
}

@Inject @Lang(EN) @Country(US) Service&lt;MyService&gt; service;</pre><p>The behavior is similar with classic CDI qualifiers. But there another
                    possibility in order to qualify a service.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1442"/>3.2.4.2. Filtering services</h4></div></div></div><p>Since CDI-OSGi services stay OSGi services they can be filtered through LDAP
                    filter. Properties might be added at publishing using the <code class="code">Publish</code>
                    annotation values. Then an LDAP filter can be use at injection point using the
                        <code class="code">Filter</code> annotation. </p><p>An example is worth a thousand words:
                    </p><pre class="programlisting">@Publish({
    @Property(name="lang", value="EN"),
    @Property(name="country", value="US")
})
@ApplicationScoped
public class MyServiceImpl implements MyService {

    @Override
    public void doSomething() {
    }
}</pre><p>As
                    many <code class="code">@Property</code> annotation as wanted can be added, they are
                    registered with the service implementation.</p><p>Then it is possible to filter an injection point with the <code class="code">Filter</code>
                    annotation like a regular LDAP filter:
                    </p><pre class="programlisting">@Inject @Filter("(&amp;(lang=*)(country=US))") Service&lt;MyService&gt; service;</pre><p>or</p><pre class="programlisting">@Inject @Filter("(&amp;(lang=*)(country=US))") MyService service;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1471"/>3.2.4.3. Links between qualifier annotations and LDAP filtering</h4></div></div></div><p>A service implementation has properties. These properties can be added by both
                        <code class="code">Qualifier</code> annotations and <code class="code">Property</code> annotations of
                    a <code class="code">Filter</code> annotation. Therefore there is a link between
                        <code class="code">Qualifier</code> and LDAP filter used in <code class="code">Filter</code>
                    annotation as <code class="code">Property</code>.</p><p>A property is a couple of <code class="code">String</code>, the first entry is the name of
                    the property, the second the value. This scheme is clear in the
                        <code class="code">Property</code> annotation. For <code class="code">Qualifier</code> the property
                    name is the decapitalized <code class="code">Qualifier</code> class name and the property
                    value is the <code class="code">value</code> of the <code class="code">Qualifier</code> (empty
                        <code class="code">String</code> is assumed if <code class="code">value</code> does not exist).</p><p>
                    </p><pre class="programlisting">@Publish
@Lang(EN)
@Country(US)
@ApplicationScoped
public class MyServiceImpl implements MyService {
}

@Inject @Filter("(&amp;(lang=EN)(country=US))") Service&lt;MyService&gt; service;</pre><p>
                </p><p>
                    </p><pre class="programlisting">@Publish({
    @Property(name="lang", value="EN"),
    @Property(name="country", value="US")
})
@ApplicationScoped
public class MyServiceImpl implements MyService {
}

@Inject @Lang(EN) @Country(US) Service&lt;MyService&gt; service;</pre><p>
                </p><p>It is even possible to mix up <code class="code">Qualifier</code> and
                    <code class="code">Property</code>:
                    </p><pre class="programlisting">@Publish({
    @Property(name="lang", value="EN"),
})
@Country(US)
@ApplicationScoped
public class MyServiceImpl implements MyService {
}

@Inject @Filter("lang=EN") @Country(US) Service&lt;MyService&gt; service;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1540"/>3.2.4.4. Filtering after injection</h4></div></div></div><p>It is possible to do a programmatic filtering after injection using
                        <code class="code">Service&lt;T&gt;</code> like with
                    <code class="code">Instance&lt;T&gt;</code>:</p><pre class="programlisting">@Inject Service&lt;MyService&gt; services;
services.select(new AnnotationLiteral&lt;AnyQualifier&gt;() {}).get().deSomething();</pre><p>or</p><pre class="programlisting">@Inject Service&lt;MyService&gt; services;
services.select("(&amp;(lang=*)(country=US))").get().deSomething();</pre><p>However OSGi service may not be subtyped, thus it is not possible to use
                        <code class="code">select()</code> methods with a specified subclass like with
                        <code class="code">Instance&lt;T&gt;</code></p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1563"/>3.2.5. Contextual services</h3></div></div></div><p>Like for bean instances, service instances are contextual. Every implementation is
                bounded to a particular scope. Provided that an satisfactory implementation is
                available, a service injection will return a contextual instance of the
                implementation.</p><p>All CDI scopes are available for CDI-OSGi services and their use is the same:
                </p><pre class="programlisting">@Publish
@ApplicationScoped
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}</pre><p>A
                instance will be shared by the entire
                application.</p><pre class="programlisting">@Publish
@RequestScoped
public class MyServiceImpl implements MyService {
    @Override
    public void doSomething() {
    }
}                </pre><p>A
                new instance is created for every request.</p><p>If no scope is provided <code class="code">Dependent</code> scope is assumed, a new instance
                will be create for every injection. An instance obtained with regular OSGi
                mechanisms assumes a <code class="code">ApplicationScoped</code> scope in order to maintain
                regular OSGi comportment.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1584"/>3.2.6. The registration</h3></div></div></div><p>A registration object represent all the bindings between a service contract class
                and its OSGi <code class="code">ServiceRegistration</code>s. With this object it is possible to
                navigate through multiple implementations of the same service, obtain the
                corresponding <code class="code">Service&lt;T&gt;</code> or unregister these implementations.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1595"/>3.2.6.1. registration injection</h4></div></div></div><p>A registration is obtained like
                    that:</p><pre class="programlisting">@Inject Registration&lt;MyService&gt; registrations;</pre><p>The
                    injection point can be filtered using
                    qualifiers:</p><pre class="programlisting">@Inject @AnyQualifier Registration&lt;MyService&gt; qualifiedRegistrations;</pre><p>or
                    using LDAP
                    filter:</p><pre class="programlisting">@Inject @Filter("(&amp;(lang=EN)(country=US))") Registration&lt;MyService&gt; qualifiedRegistrations;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1608"/>3.2.6.2. Navigate into registrations and filter them</h4></div></div></div><p>It is possible to iterate through
                    registration:</p><pre class="programlisting">if(registrations.size() &gt; 0) {
    for(Registration&lt;T&gt; registration : registrations) {
    }
}</pre><p>It is also possible to request a subset of the service implementations using
                    qualifiers:</p><pre class="programlisting">Registration&lt;T&gt; filteredRegistrations = registrations.select(new AnnotationLiteral&lt;AnyQualifier&gt;() {});</pre><p>or
                    a LDAP
                    filter:</p><pre class="programlisting">Registration&lt;T&gt; filteredRegistrations = registrations.select("(&amp;(lang=EN)(country=US))");</pre><p>or
                    both:</p><pre class="programlisting">Registration&lt;T&gt; filteredRegistrations = registrations.select(new AnnotationLiteral&lt;AnyQualifier&gt;() {}).select("(&amp;(lang=EN)(country=US))");</pre><p>Link
                    between qualifier and LDAP filter as well as subtyped service selection are
                    explain above in service injection section.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1626"/>3.2.6.3. Registration usages</h4></div></div></div><p>A registration allows to obtain service
                    implementations:</p><pre class="programlisting">Service&lt;T&gt; myServiceImplementations = registrations.getServiceReference();</pre><p>And
                    it allows to unregister service
                    implementations:</p><pre class="programlisting">registrations.unregister();</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1636"/>3.2.7. Service registry</h3></div></div></div><p>CDI-OSGi offers another way to deal with services: the service registry. It can be
                obtained in any bean bundle as a injected bean. The service registry allows
                developers to dynamically register service implementation, to obtain services and
                registrations.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1641"/>3.2.7.1. First get the service registry</h4></div></div></div><p>First get the service registry:
                    </p><pre class="programlisting">@Inject ServiceRegistry registry;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1648"/>3.2.7.2. Register a service implementation</h4></div></div></div><p>Register a service implementation:
                    </p><pre class="programlisting">registry.registerService(MyService.class,MyServiceImpl.class);</pre><p>
                    or
                    </p><pre class="programlisting">MyServiceImpl implementation = new MyServiceImpl();
registry.registerService(MyService.class,implementation);</pre><p>It is possible to collect the corresponding registration:
                    </p><pre class="programlisting">Registration&lt;MyService&gt; registeredService = registry.registerService(MyService.class,MyServiceImpl.class);</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1662"/>3.2.7.3. Obtain a service implementations</h4></div></div></div><p>Obtain a service implementations:
                    </p><pre class="programlisting">Service&lt;MyService&gt; services = registry.getServiceReference(MyService.class);
for (MyService service : services) {
    service.doSomething();
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1669"/>3.2.7.4. Obtain registrations</h4></div></div></div><p>Obtain all registrations of a filtered or not filtered specified service:
                    </p><pre class="programlisting">Registration&lt;?&gt; registrations = registry.getRegistrations();
Registration&lt;MyService&gt; myRegistrations = registry.getRegistrations(MyService.class);
Registration&lt;MyService&gt; myFrenchRegistrations = registry.getRegistrations(MyService.class,"(lang=FR)");     </pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1676"/>3.2.8. The <code class="code">OSGiServiceUnavailableException</code> exception</h3></div></div></div><p>Because OSGi service are dynamic they might be unavailable at the time they should
                be used. On a service call if the targeted service isn't available a specific
                runtime exception is raised:
                </p><pre class="programlisting">public class OSGiServiceUnavailableException extends RuntimeException {}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1686"/>3.3. CDI-OSGi events</h2></div></div></div><p>CDI-OSGi makes heavy usage of CDI events. These events allow CDI-OSGi to do its work.
            Events are important for the running of CDI-OSGi itself but they can also be used by
            client bean bundles to perform some operations or override some normal CDI-OSGi
            behavior.</p><p>This section shows the numerous events provided by CDI-OSGi and the ways to use
            them.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1693"/>3.3.1. CDI container lifecycle events</h3></div></div></div><p>Two events inform about the state of the CDI container of every bean bundle:
                    <code class="code">BundleContainerInitialized</code> and <code class="code">BundleContainerShutdown</code>
                events.</p><p>The <code class="code">BundleContext</code> from where the event comes is sent with these
                events so developers can retrieve useful information (such as the bundle owning the
                CDI container).</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1709"/>3.3.1.1. When the container is started: <code class="code">BundleContainerInitialized</code>
                    event</h4></div></div></div><p>The <code class="code">BundleContainerInitialized</code> event is fired every time a CDI
                    container is initialized in a bean bundle. It point out that the CDI container
                    is ready to manage the bean bundle with the CDI-OSGi features.</p><p>Here the way to listen this event:
                    </p><pre class="programlisting">public void onStartup(@Observes BundleContainerInitialized event) {
    BundleContext bundleContext = event.getBundleContext();
    Bundle firingBundle = bundleContext.getBundle();
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1724"/>3.3.1.2. When the container is stopped: <code class="code">BundleContainerShutdown</code>
                    event</h4></div></div></div><p>The <code class="code">BundleContainerShutdown</code> event is fired every time a CDI
                    container is stopped in a bean bundle. It point out that the CDI container wil
                    not manage the bean bundle with CDI-OSGi anymore.</p><p>Here the way to listen this
                    event:</p><pre class="programlisting">public void onShutdown(@Observes BundleContainerShutdown event) {
    BundleContext bundleContext = event.getBundleContext();
    Bundle firingBundle = bundleContext.getBundle();
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1739"/>3.3.2. Bundle lifecycle events</h3></div></div></div><p>Ten events might be fired during a bundle lifecycle. They represent the possible
                states of a bundle and monitor the changes occurred in bundle lifecycles. These
                events carry the <code class="code">Bundle</code> object from where the event comes so developers
                can retrieve useful information (such as the bundle id).</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1747"/>3.3.2.1. Listen all bundle events: <code class="code">AbstractBundleEvent</code> event</h4></div></div></div><p>CDI-OSGi provides a way to listen all bundle events in a single method: the
                        <code class="code">AbstractBundleEvent</code> abstract class. Every bundle lifecycle
                    event is an <code class="code">AbstractBundleEvent</code> and a method allows to retrieve the
                    actual fired bundle event. All bundle states are listed in the
                        <code class="code">BundleEventType</code> enumeration. Then this event can be used as the
                    corresponding bundle event.</p><p>Here the way to listen all bundle events and to retrieve the corresponding
                    bundle
                    state:</p><pre class="programlisting">public void bundleChanged(@Observes AbstractBundleEvent event) {
    BundleEventType event.getType();
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1768"/>3.3.2.2. Listen a specific bundle event</h4></div></div></div><p>Rather than listen all bundle events and then filter the intended, it is
                    possible to choose the listened bundle event.</p><p>Here the way to listen a specific bundle
                    event:</p><pre class="programlisting">public void bindBundle(@Observes BundleInstalled event) {
    Bundle bundle = event.getBundle();
    long id = event.getBundleId();
    String symbolicName = event.getSymbolicName();
    Version version = event.getVersion();
}</pre><p>All other bundle events could be listened the same way.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1779"/>3.3.2.3. Filtering bundle events: <code class="code">BundleName</code> and
                        <code class="code">BundleVersion</code> annotations</h4></div></div></div><p>It is possible to filter the listened events depending on the bundles that are
                    concerned. This filter might cover the name or the version of the
                    bundles.</p><p>Here the way to filter bundle events on the bundle
                    names:</p><pre class="programlisting">public void bindBundle(@Observes @BundleName("com.sample.gui") BundleInstalled event) {
}</pre><p>or
                    on the bundle
                    versions:</p><pre class="programlisting">public void bindBundle(@Observes @BundleVersion("4.2.1") BundleInstalled event) {
}</pre><p>or
                    on both bundle names and
                    versions:</p><pre class="programlisting">public void bindBundle(@Observes @BundleName("com.sample.gui") @BundleVersion("4.2.1") BundleInstalled event) {
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1800"/>3.3.3. Service lifecyle events</h3></div></div></div><p>Three events might be fired during a service lifecycle. They represent the
                possible states of a service and monitor the changes occurred in service lifecycles.
                These events carry the <code class="code">BundleContext</code> object from where the event comes
                and the <code class="code">ServiceReference</code> object corresponding to the service so
                developers can retrieve useful information (such as the registering bundle) and
                acces useful actions (such as register or unregister services).</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1811"/>3.3.3.1. Listen all service events: <code class="code">AbstractServiceEvent</code> event</h4></div></div></div><p>CDI-OSGi provides a way to listen all service events in a single method: the
                        <code class="code">AbstractServiceEvent</code> abstract class. Every service lifecycle
                    event is an <code class="code">AbstractServiceEvent</code> and a method allows to retrieve
                    the actual fired service event. All service states are listed in the
                        <code class="code">ServiceEventType</code> enumeration. Then this event can be used as
                    the corresponding service event.</p><p>Here the way to listen all service events and to retrieve the corresponding
                    service
                    state:</p><pre class="programlisting">public void serviceEvent(@Observes AbstractServiceEvent event) {
    ServiceEventType event.getType();
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1832"/>3.3.3.2. When a service is published: <code class="code">ServiceArrival</code> event</h4></div></div></div><p>Rather than listen all service events and then filter the intended, it is
                    possible to choose the listened service event.</p><p>Here the way to listen a specific service event:</p><pre class="programlisting">public void bindService(@Observes ServiceArrival event) {
    ServiceReference serviceReference = event.getRef();
    Bundle registeringBundle = event.getRegisteringBundle();
}</pre><p>All
                    other bundle events could be listened the same way.</p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1846"/>3.3.3.3. Filtering service events: <code class="code">Specification</code> and <code class="code">Filter</code>
                    annotations</h4></div></div></div><p>It is possible to filter the listened events depending on the services that
                    are concerned. This filter might cover the service specification class or it
                    might be a LDAP filter.</p><p>Here the way to filter service events on the specification
                    class:</p><pre class="programlisting">public void bindService(@Observes @Specification(MyService.class) ServiceArrival event) {
}</pre><p>or
                    using a LDAP
                    filter:</p><pre class="programlisting">public void bindService(@Observes @Specification(MyService.class) ServiceArrival event) {
}</pre><p>or
                    on both specification class and LDAP
                    filter:</p><pre class="programlisting">public void bindService(@Observes @Specification(MyService.class) @Filter("(&amp;(lang=EN)(country=US))") ServiceArrival event) {
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1867"/>3.3.4. Application dependency validation events</h3></div></div></div><p>Some bean bundle might declare required dependencies on services (using the
                    <code class="code">Required</code> annotation). CDI-OSGi fired events when these required
                dependencies are all validated or when at least one is invalidated. It allows
                application to be automatically started or stopped.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1875"/>3.3.4.1. When all dependencies are validated: <code class="code">Valid</code> event</h4></div></div></div><p>An event is fired every time all the required dependencies are
                    validated.</p><p>Here the way to listen this event:
                    </p><pre class="programlisting">public void validate(@Observes Valid event) {
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1887"/>3.3.4.2. When at least one dependency is invalidated: <code class="code">Invalid</code>
                    event</h4></div></div></div><p>An event is fired every time at least one of the required dependencies is
                    invalidated.</p><p>Here the way to listen this event:
                    </p><pre class="programlisting">public void invalidate(@Observes Invalid event) {
}</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1899"/>3.3.5. Intra and inter bundles communication events</h3></div></div></div><p>CDI-OSGi provides a way to communicate within and between bean bundles. This
                communication occurs in a totally decoupled manner using CDI events.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1904"/>3.3.5.1. Firing a bundle communication event: <code class="code">InterBundleEvent</code>
                    event</h4></div></div></div><p>An <code class="code">InterBundleEvent</code> is a message containing a object and
                    transmitted using CDI event.</p><p>Here the way to fire such an
                    event:</p><pre class="programlisting">@Inject Event&lt;InterBundleEvent&gt; event;
MyMessage myMessage = new MyMessage();
event.fire(new InterBundleEvent(myMessage));</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1919"/>3.3.5.2. When a bundle communication is received: <code class="code">InterBundleEvent</code>
                    event</h4></div></div></div><p>When an <code class="code">InterBundleEvent</code> is fired it might be catch either within
                    the bundle or in other bundles or both.</p><p>Here the way to receive a communication event from within the
                    bundle:</p><pre class="programlisting">public void listenAllEvents(@Observes InterBundleEvent event) {
}</pre><p>Here the way to receive a communication event from another
                    bundles:</p><pre class="programlisting">public void listenAllEventsFromOtherBundles(@Observes @Sent InterBundleEvent event) {
}</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h4 class="title"><a id="d0e1938"/>3.3.5.3. Filtering communication events: <code class="code">Specification</code> annotation</h4></div></div></div><p>It is possible to filter the listened events depending on the message type.
                    This filter may specify the type of message that is listened.</p><p>Here the way to filter communication events specifying a message type:
                    </p><pre class="programlisting">public void listenStringEventsFromOtherBundles(@Observes @Sent @Specification(MyMessage.class) InterBundleEventevent) {
}</pre><p>Only
                    the message with type <code class="code">MyMessage</code> will be received.</p></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1954"/>3.4. OSGi utilities</h2></div></div></div><p>CDI-OSGi provide some facilities for OSGi usage. It allows to obtain, by injection,
            some of the useful objects of the OSGi environment.</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1959"/>3.4.1. From the current bundle</h3></div></div></div><p>Here a way to obtain the current
                bundle:</p><pre class="programlisting">@Inject Bundle bundle;</pre><p>Here a way to obtain the current bundle
                context:</p><pre class="programlisting">@Inject BundleContext bundleContext;</pre><p>Here a way to obtain all the current bundle
                headers:</p><pre class="programlisting">@Inject @BundleHeaders Map&lt;String,String&gt;metadata;</pre><p>or
                a particular
                header</p><pre class="programlisting">@Inject @BundleHeader("Bundle-SymbolicName") String symbolicName;</pre><p>Here a way to obtain a resource file from the current
                bundle:</p><pre class="programlisting">@Injec @BundleDataFile("test.txt") File file;</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1981"/>3.4.2. From external bundle</h3></div></div></div><p>Here a way to obtain a specified bundle from its name and
                version:</p><pre class="programlisting">@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") bundle;</pre><p>or
                just from its
                name:</p><pre class="programlisting">@Inject @BundleName("com.sample.gui") bundle;</pre><p>Here a way to obtain all the specified bundle
                headers:</p><pre class="programlisting">@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") @BundleHeaders Map&lt;String,String&gt;metadata;</pre><p>or
                a particular
                header:</p><pre class="programlisting">@Inject @BundleName("com.sample.gui") @BundleVersion("4.2.1") @BundleHeader("Bundle-SymbolicName") String symbolicName;</pre></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1998"/>3.5. CDI-OSGi, what else ?</h2></div></div></div><p>Here there are some examples that concretely show what CDI-OSGi is avoiding to the
            developer:</p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2003"/>3.5.1. Getting service references and instances</h3></div></div></div><p>How to obtain a service available implementations list ?</p><p>In
                CDI-OSGI:</p><pre class="programlisting"><span class="bold"><strong>@Inject</strong></span> Service&lt;MyService&gt; references;</pre><p>versus
                in classic OSGi:
                </p><pre class="programlisting">ServiceReference references = <span class="bold"><strong>bundleContext.getServiceReferences(MyService.class.getName());</strong></span>
//Current BundleContext must be known</pre><p>How to obtain a service instance ?</p><p>In
                CDI-OSGi:</p><pre class="programlisting"><span class="bold"><strong>@Inject @OSGiService</strong></span> MyService service;</pre><p>versus
                in classic
                OSGi:</p><pre class="programlisting"><span class="bold"><strong>ServiceReference reference = bundleContext.getServiceReference(MyService.class.getName());</strong></span>
MyService service = <span class="bold"><strong>(MyService) bundleContext.getService(reference);</strong></span>
//Current BundleContext must be known</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2036"/>3.5.2. Publishing a service implementation</h3></div></div></div><p>How to publish a new service implementation ?</p><p>In CDI-OSGi:
                </p><pre class="programlisting"><span class="bold"><strong>@Publish</strong></span>
public class MyServiceImpl implements MyService {

    @Override
    void doSomething() {...}
}</pre><p>versus
                in classic OSGi:
                </p><pre class="programlisting">public class MyServiceImpl implements MyService {

    @Override
    void doSomething() {...}
}

<span class="bold"><strong>{ //in another class
    ServiceRegistration registration = bundleContext.registerService(MyService.class, new MyServiceImpl(), null);
}</strong></span>
//Current BundleContext must be known</pre></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2053"/>3.5.3. Obtaining the <code class="code">Bundle</code>s and <code class="code">BundleContext</code>s</h3></div></div></div><p>How to obtain the current <code class="code">Bundle</code> ?</p><p>In
                CDI-OSGi:</p><pre class="programlisting"><span class="bold"><strong>@Inject</strong></span> Bundle currentBundle;</pre><p>versus
                in classic
                OSGi:</p><pre class="programlisting">Bundle currentBundle = <span class="bold"><strong>FrameworkUtil.getBundle(this.getClass());</strong></span></pre><p>How to obtain the current <code class="code">BundleContext</code> ?</p><p>In
                CDI-OSGi:</p><pre class="programlisting"><span class="bold"><strong>@Inject</strong></span> BundleContext bundleContext;</pre><p>versus
                in classic
                OSGi:</p><pre class="programlisting">BundleContext bundleContext = <span class="bold"><strong>FrameworkUtil.getBundle(this.getClass()).getBundleContext();</strong></span></pre><p>How to obtain a specified <code class="code">Bundle</code> and <code class="code">BundleContext</code>
                ?</p><p>In CDI-OSGi:
                </p><pre class="programlisting"><span class="bold"><strong>@Inject @BundleNamer("symbolicName") @BundleVersion("version")</strong></span> Bundle specifiedBundle;
<span class="bold"><strong>@Inject @BundleNamer("symbolicName") @BundleVersion("version")</strong></span> BundleContext specifiedBundleContext;</pre><p>versus
                in classic
                OSGi:</p><pre class="programlisting"><span class="bold"><strong>ServiceReference reference = bundleContext.getServiceReference(PackageAdmin.class.getName());
PackageAdmin packageAdmin = bundleContext.getService(reference);</strong></span>
Bundle specifiedBundle = <span class="bold"><strong>packageAdmin.getBundles("symbolicName","version")[0];</strong></span>
BundleContext specifiedBundleContext = <span class="bold"><strong>specifiedBundle.getBundleContext();</strong></span>
//Current BundleContext must be known</pre></div></div></div><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2122"/>Chapter 4. Weld-OSGi implementation</h2></div></div></div></div></div></body></html>